#! winxed

// winxedxx.winxed
// C++ backend for winxed
// (C) 2011 Juli√°n Albo "NotFound"

// This code uses and abuses winxed compiler internals.
// Not a good example on how to write winxed compiler extensions,
// but there is no better way right now.

function WxxUnsupported(thing, string msg[optional])
{
    if (msg == null) {
        if (thing instanceof 'String')
            msg = thing;
        else
            msg = typeof(thing);
    }
    string filename = '';
    int line = 0;
    string desc;
    try {
        var start;
        if (thing instanceof Token)
            start = thing;
        else
            start = thing.start;
        filename = start.file;
        line = start.line;
        desc = start.viewable();
    }
    catch () { }
    throw Error(filename + ":" + string(line) + ": " +
            msg + " unsupported near " + desc);
}

function tokstringtoxx(strval)
{
    string str = strval.str;
    if (strval instanceof TokenQuoted)
        return str;
    if (strval instanceof TokenSingleQuoted)
    {
        string result = '';
        int n = length(str);
        int i;
        for (i = 0 ; i < n; ++i) {
            string c = substr(str, i, 1);
            if (c ==  '"' || c == '\')
                result += '\' + c;
            else
                result += c;
        }
        return result;
    }
    throw Error('Unexpected literal string type');
}

function stringtoxx(literal)
{
    var strval = literal.strval;
    string str = strval.str;
    if (strval instanceof TokenQuoted)
        return str;
    if (strval instanceof TokenSingleQuoted)
    {
        string result = '';
        int n = length(str);
        int i;
        for (i = 0 ; i < n; ++i) {
            string c = substr(str, i, 1);
            if (c ==  '"' || c == '\')
                result += '\' + c;
            else
                result += c;
        }
        return result;
    }
    throw Error('Unexpected literal string type');
}

function emit_callpredefexpr(out, expr)
{
    var predef = expr.predef;
    string name = predef.name;
    var args = expr.args;
    int nargs = elements(args);
    int i;
    switch (name) {
      case 'string':
        out.print("std::string");
        emit_expr(out, args[0].arg);
        break;
      case 'typeof':
        out.print("www_typeof");
        emit_expr(out, args[0].arg);
        break;
      case 'getstdin':
      case 'getstdout':
      case 'getstderr':
        out.print("wxx_" + name + "()");
        break;
      case 'print':
      case 'say':
        for (i = 0;  i < nargs; ++i) {
            var arg = args[i];
            var argexp = arg.arg;
            out.print('wxx_print');
            emit_expr(out, argexp);
            out.print(',');
        }
        if (predef.name == 'say')
            out.print('wxx_print("\n"),');
        out.print('0');
        break;
      case 'elements':
        emit_expr(out, args[0].arg);
        out.print(".elements()");
        break;
      case 'length':
        emit_expr(out, args[0].arg);
        out.print(".length()");
        break;
      case 'indexof':
        out.print("int((");
        emit_expr(out, args[0].arg);
        out.print(").find(");
        emit_expr(out, args[1].arg);
        out.print("))");
        break;
      case 'substr':
        emit_expr(out, args[0].arg);
        out.print(".substr(");
        emit_expr(out, args[1].arg);
        out.print(", ");
        emit_expr(out, args[2].arg);
        out.print(")");
        break;
      case 'Error':
        out.print("wxx_error(");
        emit_expr(out, args[0].arg);
        if (nargs > 1) {
            out.print(", ");
            emit_expr(out, args[1].arg);
        }
        if (nargs > 2) {
            out.print(", ");
            emit_expr(out, args[2].arg);
        }
        out.print(")");
        break;
      case 'open':
        out.print("WxxObjectPtr((new WxxFileHandle())->open(");
        emit_expr(out, args[0].arg);
        out.print("))");
        break;
      default:
        WxxUnsupported(expr, "predef " + name);
    }
}

function emit_callexpr(out, callexpr)
{
    var funref = callexpr.funref;
    var args = callexpr.args;
    int nargs = 0;
    if (args != null)
        nargs = args.numargs();
    if (funref.isidentifier()) {
        string callname = funref.getName();
        out.print(callname);
        out.print("(WxxObjectArray()");
        if (nargs > 0) {
            for (int i = 0; i < nargs; ++i) {
                out.print(".push(");
                var arg = args.getfreearg(i);
                emit_expr(out, arg);
                out.print(")");
            }
        }
        out.print(")");
    }
    else if (funref instanceof MemberExpr) {
        emit_expr(out, funref.left);
        out.print(".call_method(\"");
        out.print(funref.right.getidentifier());
        out.print("\"");
        if (nargs > 0) {
            out.print(", WxxObjectArray()");
            for (int i = 0; i < nargs; ++i) {
                out.print(".push(");
                var arg = args.getfreearg(i);
                emit_expr(out, arg);
                out.print(")");
            }
        }
        out.print(")");
    }
    else
        WxxUnsupported(funref);
}

function emit_assignexpr(out, assignexpr)
{
    var lexpr = assignexpr.lexpr;
    if (lexpr instanceof IdentifierExpr) {
        out.print(lexpr.name);
        out.print(" = ");
        emit_expr(out, assignexpr.rexpr);
    }
    else
        WxxUnsupported(lexpr);
}

function emit_instanceofexpr(out, instanceofexpr)
{
    var lexpr = instanceofexpr.lexpr;
    var checked = instanceofexpr.checked;
    out.print("wxx_instanceof(");
    emit_expr(out, lexpr);
    out.print(", ");
    if (checked.isidentifier())
        out.print('"' + string(checked.getidentifier()) + '"');
    else
        out.print('"' + string(tokstringtoxx(checked)) + '"');
    out.print(")");
}

function emit_addtoexpr(out, assignexpr)
{
    var lexpr = assignexpr.lexpr;
    if (lexpr instanceof IdentifierExpr) {
        out.print(lexpr.name);
        out.print(" += ");
        emit_expr(out, assignexpr.rexpr);
    }
    else
        WxxUnsupported(lexpr);
}

function emit_concatstring(out, concatstr)
{
    var values = concatstr.values;
    emit_expr(out, values[0]);
    int n = elements(values);
    for (int i = 1; i < n; ++i) {
        out.print(" + ");
        emit_expr(out, values[i]);
    }
}

function emit_nullchecker(out, expr)
{
    if (! expr.checknull)
        out.print("!");
    out.print("(");
    out.print("wxx_isnull");
    emit_expr(out, expr.expr);
    out.print(")");
}

function emit_opnot(out, expr)
{
    out.print("!");
    emit_expr(out, expr.subexpr);
}

function emit_commonop(out, expr, string opstr)
{
    emit_expr(out, expr.lexpr);
    out.print(" ");
    out.print(opstr);
    out.print(" ");
    emit_expr(out, expr.rexpr);
}

function emit_boolorexpr(out, lessexpr)
{
    out.print("wxx_boolor(");
    emit_expr(out, lessexpr.lexpr);
    out.print(", ");
    emit_expr(out, lessexpr.rexpr);
    out.print(")");
}

function emit_boolandexpr(out, lessexpr)
{
    out.print("wxx_booland(");
    emit_expr(out, lessexpr.lexpr);
    out.print(", ");
    emit_expr(out, lessexpr.rexpr);
    out.print(")");
}

function emit_conditionalexpr(out, expr)
{
    emit_expr(out, expr.condition.condexpr);
    out.print(" ? ");
    emit_expr(out, expr.etrue);
    out.print(" : ");
    emit_expr(out, expr.efalse);
}

function emit_identifierexpr(out, expr)
{
    string name = expr.name;
    if (name == "null")
        out.print("winxednull");
    else
        out.print(name);
}

function emit_indexexpr(out, expr)
{
    var left = expr.left;
    emit_expr(out, left);
    var arg = expr.getarg(0);
    out.print(".get_pmc_keyed");
    emit_expr(out, arg);
}

function emit_memberexpr(out, expr)
{
    emit_expr(out, expr.left);
    out.print(".get_attr_str(\"");
    out.print(expr.right.getidentifier());
    out.print("\")");
}

function emit_expr(out, expr)
{
    out.print("(");

    if (expr instanceof CallPredefExpr)
        emit_callpredefexpr(out, expr);
    else if (expr instanceof CallExpr)
        emit_callexpr(out, expr);
    else if (expr instanceof OpAssignExpr)
        emit_assignexpr(out, expr);
    else if (expr instanceof OpAddToExpr)
        emit_addtoexpr(out, expr);
    else if (expr instanceof IdentifierExpr)
        emit_identifierexpr(out, expr);
    else if (expr instanceof IntegerLiteral)
        out.print(expr.getIntegerValue());
    else if (expr instanceof FloatLiteral)
        out.print(expr.numval);
    else if (expr instanceof StringLiteral) {
        out.print('"');
        out.print(stringtoxx(expr));
        out.print('"');
    }
    else if (expr instanceof OpNotExpr)
        emit_opnot(out, expr);
    else if (expr instanceof NullCheckerExpr)
        emit_nullchecker(out, expr);
    else if (expr instanceof OpInstanceOfExpr)
        emit_instanceofexpr(out, expr);
    else if (expr instanceof OpPreIncExpr) {
        out.print('++');
        emit_expr(out, expr.subexpr);
    }
    else if (expr instanceof ConcatString)
        emit_concatstring(out, expr);
    else if (expr instanceof OpEqualExpr)
        emit_commonop(out, expr, "==");
    else if (expr instanceof OpNotEqualExpr)
        emit_commonop(out, expr, "!=");
    else if (expr instanceof OpLessEqualExpr)
        emit_commonop(out, expr, "<=");
    else if (expr instanceof OpLessExpr)
        emit_commonop(out, expr, "<");
    else if (expr instanceof OpGreaterExpr)
        emit_commonop(out, expr, ">");
    else if (expr instanceof OpGreaterEqualExpr)
        emit_commonop(out, expr, ">=");
    else if (expr instanceof OpBoolOrExpr)
        emit_boolorexpr(out, expr);
    else if (expr instanceof OpBoolAndExpr)
        emit_boolandexpr(out, expr);
    else if (expr instanceof OpModExpr)
        emit_commonop(out, expr, "%");
    else if (expr instanceof OpPreDecExpr) {
        out.print('--');
        emit_expr(out, expr.subexpr);
    }
    else if (expr instanceof OpConditionalExpr)
        emit_conditionalexpr(out, expr);
    else if (expr instanceof MemberExpr)
        emit_memberexpr(out, expr);
    else if (expr instanceof IndexExpr)
        emit_indexexpr(out, expr);
    else
        WxxUnsupported(expr);
    out.print(")");
}

function emit_exprst(out, exprst)
{
    var expr = exprst.expr;
    emit_expr(out, expr);
}

function emit_conststatement(out, st)
{
}

function emit_varstatement(out, st)
{
    out.print("WxxObjectPtr ");
    out.print(st.name);
    var init = st.init;
    if (init != null) {
        out.print(" = ");
        emit_expr(out, init);
    }
}

function emit_intstatement(out, st)
{
    out.print("int ");
    out.print(st.name);
    if (st.init == null)
        out.print(" = 0");
    else {
        out.print(" = ");
        emit_expr(out, st.init);
    }
}

function emit_floatstatement(out, st)
{
    out.print("double ");
    out.print(st.name);
    if (st.init == null)
        out.print(" = 0.0");
    else {
        out.print(" = ");
        emit_expr(out, st.init);
    }
}

function emit_stringstatement(out, st)
{
    out.print("std::string ");
    out.print(st.name);
    if (st.init == null)
        out.print(' = ""');
    else {
        out.print(" = ");
        emit_expr(out, st.init);
    }
}

function emit_labelstatement(out, labelst)
{
    out.print(labelst.name);
    out.print(":\n");
}

function emit_breakstatement(out, gotost)
{
    out.print("break");
}

function emit_gotostatement(out, gotost)
{
    out.print("goto ");
    out.print(gotost.label);
}

function emit_ifstatement(out, ifst)
{
    var truebranch = ifst.truebranch;
    var falsebranch = ifst.falsebranch;
    out.print('if ');
    emit_expr(out, ifst.condexpr);
    out.print("\n{\n");
    if (! truebranch.isempty())
        emit_statement(out, truebranch);
    out.print("} else {\n");
    if (! falsebranch.isempty())
        emit_statement(out, falsebranch);
    out.print("}\n");
}

function emit_switchstatement(out, switchst)
{
    var case_value = switchst.case_value;
    var case_st = switchst.case_st;
    out.print("do {\nWxxObjectPtr wxxswvar = ");
    emit_expr(out, switchst.condition);
    out.print(";\n");

    int n = elements(case_st);
    for (int i = 0; i < n; ++i) {
        var caseval = case_value[i];
        out.print ("if ((wxxswvar == ");
        emit_expr(out, caseval);
        out.print(") {\n");
        int nst = elements(case_st[i]);
        int j;
        for (j = 0; j < nst; ++j)
            emit_statement(out, case_st[i][j]);
        out.print("}\n");
    }

    out.print("} while (false)\n");
}

function emit_whilestatement(out, ifst)
{
    out.print('while ');
    emit_expr(out, ifst.condexpr);
    out.print("\n");
    emit_statement(out, ifst.body);
}

function emit_trystatement(out, tryst)
{
    out.print("try\n{\n");
    emit_statement(out, tryst.stry);
    out.print("}\ncatch (");
    if (tryst.exname == null)
        out.print("...");
    else {
        out.print("WxxObjectPtr &");
        out.print(string(tryst.exname));
    }
    out.print(")\n{\n");
    emit_statement(out, tryst.scatch);
    out.print("}\n");
}

function emit_throwstatement(out, throwst)
{
    out.print("throw ");
    emit_expr(out, throwst.excep);
}

function emit_forstatement(out, forst)
{
    emit_statement(out, forst.initializer);

    out.print("for (");
    emit_statement(out, forst.initializer);
    emit_expr(out, forst.condexpr);
    out.print(";");
    emit_expr(out, forst.iteration);
    out.print(") {\n");
    emit_statement(out, forst.body);
    out.print("}\n");
}

function emit_returnstatement(out, returnst)
{
    var values = returnst.values;
    int nargs = values == null ? 0 : values.numargs();
    switch (nargs) {
      case 0:
        out.print("return WxxObjectPtr()");
        break;
      case 1:
        var expr = values.getfreearg(0);
        out.print("return ");
        emit_expr(out, expr);
        break;
      default:
        WxxUnsupported(returnst);
    }
}

function emit_compoundstatement(out, compound)
{
    var stlist = compound.statements;
    int nst = elements(stlist);
    int i;
    for (i = 0; i < nst; ++i) {
        var st = stlist[i];
        emit_statement(out, st);
    }
}

function emit_multistatement(out, mst)
{
    var stlist = mst.statements;
    int nst = elements(stlist);
    int i;
    for (i = 0; i < nst; ++i) {
        var st = stlist[i];
        emit_statement(out, st);
    }
}

function emit_statement(out, st)
{
    if (st instanceof MultiStatement)
        emit_multistatement(out, st);
    else if (st instanceof CompoundStatement)
        emit_compoundstatement(out, st);
    else if (st instanceof ConstStatement)
        emit_conststatement(out, st);
    else if (st instanceof IntStatement)
        emit_intstatement(out, st);
    else if (st instanceof FloatStatement)
        emit_floatstatement(out, st);
    else if (st instanceof StringStatement)
        emit_stringstatement(out, st);
    else if (st instanceof VarStatement)
        emit_varstatement(out, st);
    else if (st instanceof LabelStatement)
        emit_labelstatement(out, st);
    else if (st instanceof BreakStatement)
        emit_breakstatement(out, st);
    else if (st instanceof GotoStatement)
        emit_gotostatement(out, st);
    else if (st instanceof IfStatement)
        emit_ifstatement(out, st);
    else if (st instanceof SwitchStatement)
        emit_switchstatement(out, st);
    else if (st instanceof WhileStatement)
        emit_whilestatement(out, st);
    else if (st instanceof TryStatement)
        emit_trystatement(out, st);
    else if (st instanceof ThrowStatement)
        emit_throwstatement(out, st);
    else if (st instanceof ForStatement)
        emit_forstatement(out, st);
    else if (st instanceof ReturnStatement)
        emit_returnstatement(out, st);
    else if (st instanceof ExprStatement)
        emit_exprst(out, st);
    else if (st instanceof EmptyStatement)
        /* Do nothing */ ;
    else
        WxxUnsupported(st);
    out.print(";\n");
}

function emit_function(out, funst)
{
    string name = funst.name;

    out.print('WxxObjectPtr ');
    out.print(name);
    out.print("(");
    out.print("const WxxObjectArray &wxx_fun_args");
    out.print(")\n{\n");
    var params = funst.params;
    int nparams = params == null ? 0 : elements(params);
    int i;
    for (i = 0; i < nparams; ++i) {
        var param = params[i];
        string name = param['name'];
        var a = funst.getvar(name);
        string type = a.gettype();
        switch (type) {
          case 'I':
            out.print("int"); break;
          case 'N':
            out.print("double"); break;
          case 'S':
            out.print("std::string"); break;
          default:
            out.print("WxxObjectPtr"); break;
        }
        out.print(" ");
        out.print(name);
        out.print(" = *(wxx_fun_args[");
        out.print(i);
        out.print("]);\n");
    }

    // Get body. Should be a CompundStatement
    var body = funst.body;
    emit_statement(out, body);
    out.print("\nreturn winxedxxnull;\n}\n");
}

//**************************************************************

function get_winxed_compiler()
{
    // Load language module. If that fails, load the stage 2 bytecode.
    var winxed;
    try {
        winxed = load_language('winxed');
    } catch () { }
    if (winxed == null) {
        using extern winxedst2; // Must be installed, or use -L
        winxed = compreg('winxed');
    }
    return winxed;
}

function emit_classst(out, clst)
{
    WxxUnsupported(clst, "class is still");
}

function emit_namespacest(out, ns)
{
    if (! (ns instanceof RootNamespace)) {
        out.print("namespace ");
        out.print(ns.name);
        out.print("\n{\n");
    }
    var items = ns.items;
    for (var item in items) {
        if (item instanceof FunctionStatement)
            emit_function(out, item);
        else if (item instanceof NamespaceStatement)
            emit_namespacest(out, item);
        else if (item instanceof ClassStatement)
            emit_classst(out, item);
        else if (item instanceof MultiStatement)
            emit_statement(out, item);
        else
            WxxUnsupported(item);
    }
    if (! (ns instanceof RootNamespace))
        out.print("\n}\n");
}

function emit(out, parsed)
{
    out.print(<<:HEADER
// Generated by winxedxx

#include "winxedxx.h"

namespace WinxedXX
{

HEADER:>>
    );

    var ns = parsed.rootns;
    emit_namespacest(out, ns);

    out.print(<<:FOOTER
} // namespace WinxedXX

int main(int argc, char **argv)
{
    try {
        WinxedXX::WxxObjectArray *args = new WinxedXX::WxxObjectArray();
        for (int i = 0; i < argc; ++i)
            args->push(argv[i]);
        WinxedXX::WxxObjectPtr mainarg(args);
        WinxedXX::WxxObjectPtr objresult =
                WinxedXX::main(WinxedXX::WxxObjectArray().push(mainarg));
        int result = objresult.is_null() ? 0 : int(objresult);
        return result;
    }
    catch (WinxedXX::WxxObjectPtr &e) {
        std::cerr << "Exception caught:\n\t";
        std::cerr.flush();
        std::cerr << e.get_string() << '\n';
        return 1;
    }
    catch (const std::exception &e) {
        std::cerr << "Error: " << e.what() << '\n';
        return 1;
    }
}

// End
FOOTER:>>
    );
}

function winxedxx_get_options(argv)
{
    int argc = elements(argv);
    int i;
    var options = {};
    int nomore = false;
    for (i = 1; i < argc; ++i) {
        switch (argv[i]) {
          case '-o':
            options['outfile'] = argv[++i];
            break;
          default:
            nomore = true;
        }
        if (nomore)
            break;
    }
    options['sourcefile'] = argv[i];
    return options;
}

function winxedxx_compile(options)
{
    var winxed = get_winxed_compiler();
    var parsed = winxed.compile_from_file(options['sourcefile'],
        'parse':[named('target')]
    );

    string outfile = options['outfile'];
    var out = outfile != null && outfile != '' ?
        open(outfile, "w") :
        getstdout();
    emit(out, parsed);
    if (outfile != null && outfile != '')
        out.close();
}

function main(argv)
{
    try {
        var options = winxedxx_get_options(argv);
        winxedxx_compile(options);
        return 0;
    }
    catch (e) {
        cry(e.message);
        return 1;
    }
}

// End
