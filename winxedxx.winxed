#! winxed

// winxedxx.winxed
// C++ backend for winxed
// (C) 2011 Juli√°n Albo "NotFound"

// This code uses and abuses winxed compiler internals.
// Not a good example on how to write winxed compiler extensions,
// but there is no better way right now.

//**************************************************************

// Declare used classes

namespace Winxed {
namespace Compiler {

class Token;
class TokenQuoted;
class TokenSingleQuoted;

class IntegerLiteral;
class FloatLiteral;
class StringLiteral;

class Builtin;

class ClassSpecifierStr;
class ClassSpecifierId;

class IdentifierExpr;
class MemberExpr;
class MemberRefExpr;
class IndexExpr;
class StringIndexExpr;
class OpExistsExpr;
class NewExpr;
class NewIndexedExpr;
class ArrayExpr;
class HashExpr;
class FunctionExpr;
class NullCheckerExpr;
class ConcatString;
class CallExpr;
class CallMemberExpr;
class CallBuiltinExpr;

class OpPreIncExpr;
class OpPreDecExpr;
class OpPostIncExpr;
class OpPostDecExpr;
class OpUnaryMinusExpr;
class OpAssignExpr;
class OpAssignToExpr;
class OpAddExpr;
class OpAddToExpr;
class OpSubExpr;
class RepeatString;
class OpMulExpr;
class OpDivExpr;
class OpModExpr;
class OpCModExpr;
class OpNotExpr;
class OpBinNotExpr;
class ZeroCheckerExpr;
class OpEqualExpr;
class OpSameExpr;
class OpLessEqualExpr;
class OpGreaterEqualExpr;
class OpLessExpr;
class OpGreaterExpr;
class OpBoolAndExpr;
class OpBoolOrExpr;
class OpBinOrExpr;
class OpBinAndExpr;
class OpBinXorExpr;
class OpShiftrightExpr;
class OpShiftleftExpr;
class OpInstanceOfExpr;
class OpConditionalExpr;

class EmptyStatement;
class UsingNamespaceStatement;
class UsingStatement;
class StaticStatement;
class ExternStatement;
class ExprStatement;

class MultiStatement;
class CompoundStatement;
class VarStatement;
class IntStatement;
class FloatStatement;
class StringStatement;
class IntArrayStatement;
class FloatArrayStatement;
class StringArrayStatement;
class ConstStatement;
class ReturnStatement;
class LabelStatement;
class BreakStatement;
class ContinueStatement;
class IfStatement;
class GotoStatement;
class SwitchStatement;
class SwitchCaseStatement;
class ForStatement;
class ForeachStatement;
class DoStatement;
class WhileStatement;
class TryStatement;
class ThrowStatement;

class FunctionExtern;
class FunctionStatement;
class ClassStatement;
class NamespaceStatement;
class RootNamespace;

} // namespace Compiler
} // namespace Winxed

using namespace Winxed.Compiler;

//**************************************************************

// Errors

function WxxError(string message)
{
    return Error(message, 2, __WINXED_ERROR__);
}

function WxxUnsupported(thing, string msg[optional])
{
    if (msg == null) {
        if (thing instanceof 'String')
            msg = thing;
        else
            msg = typeof(thing);
    }
    string filename = '';
    int line = 0;
    string desc;
    try {
        var start;
        if (thing instanceof Token)
            start = thing;
        else
            start = thing.start;
        filename = start.file;
        line = start.line;
        desc = start.viewable();
    }
    catch () { }
    throw WxxError(filename + ":" + string(line) + ": " +
            msg + " unsupported near " + desc);
}

//**************************************************************

// Generic functions

function foreach(params, func)
{
    if (params != null) {
        for (var param in params) {
            func(param);
        }
    }
}

// Types

const string
    // Parrot types
    REGint      = 'I',
    REGfloat    = 'N',
    REGstring   = 'S',
    REGvar      = 'P',
    // Generated types
    Type_Int    = 'int',
    Type_Num    = 'double',
    Type_String = 'std::string',
    Type_PMC    = 'WxxObjectPtr';

function generatedType(string ptype)
{
    switch (ptype) {
      case REGint:    return Type_Int;
      case REGfloat:  return Type_Num;
      case REGstring: return Type_String;
      case REGvar:    return Type_PMC;
      default:
        throw "Internal error: wrong call: generatedType " + ptype;
    }
}

//**************************************************************

function tokstringtoxx(strval)
{
    string str = strval.str;
    if (strval instanceof TokenQuoted)
        return str;
    if (strval instanceof TokenSingleQuoted)
    {
        string result = '';
        int n = length(str);
        int i;
        for (i = 0 ; i < n; ++i) {
            string c = substr(str, i, 1);
            if (c ==  '"' || c == '\')
                result += '\' + c;
            else
                result += c;
        }
        return result;
    }
    throw Error('Unexpected literal string type');
}

function stringtoxx(literal)
{
    var strval = literal.strval;
    string str = strval.str;
    if (strval instanceof TokenQuoted)
        return str;
    if (strval instanceof TokenSingleQuoted)
    {
        string result = '';
        int n = length(str);
        int i;
        for (i = 0 ; i < n; ++i) {
            string c = substr(str, i, 1);
            if (c ==  '"' || c == '\')
                result += '\' + c;
            else
                result += c;
        }
        return result;
    }
    throw Error('Unexpected literal string type');
}

function nciitemtoc(string item)
{
    switch (item)
    {
      case 'i':
        return 'int';
      case 'v':
        return 'int'; // Allow void to return something
      default:
        throw Error("signature unsupported: " + item);
    }
}

function ncisigtoc(string sig)
{
    string ret = sig[0];
    string args = substr(sig, 1);
    string csig;
    csig = nciitemtoc(ret);
    csig += "(*)(";
    string sep = '';
    for (int i = 0; i < length(args); ++i) {
        string item = args[i];
        csig += sep;
        sep = ", ";
        csig += nciitemtoc(item);
    }
    csig += ")";
    return csig;
}

function emit_callbuiltin_simple(out, string name, arg)
{
    out.print(name);
    emit_expr(out, arg);
}
function emit_callbuiltin_simple_2(out, string name, arg0, arg1)
{
    out.print(name);
    out.print("(");
    emit_expr(out, arg0);
    out.print(", ");
    emit_expr(out, arg1);
    out.print(")");
}

function emit_callbuiltinexpr(out, expr)
{
    var builtin = expr.builtin;
    string name = builtin.name;
    var args = expr.args;
    int nargs = elements(args);
    var arg0 = nargs > 0 ? args[0].arg : null;
    var arg1 = nargs > 1 ? args[1].arg : null;
    var arg2 = nargs > 2 ? args[2].arg : null;
    string type0;
    int i;
    switch (name) {
      case '__ASSERT__':
        // No --debug option yet, emit something parseable as an expression
        // that does nothing.
        out.print("(void)0");
        break;
      case 'string':
        switch (arg0.checkresult()) {
          case REGint:
            out.print("wxx_int_to_string");
            break;
          case REGvar:
            out.print(Type_String);
            break;
        }
        emit_expr(out, arg0);
        break;
      case 'int':
        out.print(Type_Int);
        emit_expr(out, arg0);
        break;
      case 'float':
        out.print(Type_Num);
        emit_expr(out, arg0);
        break;
      case 'typeof':
        out.print("wxx_typeof");
        emit_expr(out, arg0);
        break;
      case 'getstdin':
      case 'getstdout':
      case 'getstderr':
        out.print("wxx_" + name + "()");
        break;
      case 'print':
      case 'say':
        for (i = 0;  i < nargs; ++i) {
            var arg = args[i];
            var argexp = arg.arg;
            out.print('wxx_print');
            emit_expr(out, argexp);
            out.print(',');
        }
        if (builtin.name == 'say')
            out.print('wxx_print("\n"),');
        out.print('0');
        break;
      case 'cry':
        for (i = 0;  i < nargs; ++i) {
            var arg = args[i];
            var argexp = arg.arg;
            out.print('wxx_eprint');
            emit_expr(out, argexp);
            out.print(',');
        }
        out.print('wxx_eprint("\n"),');
        out.print('0');
        break;
      case 'elements':
        emit_expr(out, arg0);
        out.print(".elements()");
        break;
      case 'length':
      case 'bytelength':
        out.print("(" + Type_Int + ")(" + Type_String + "(");
        emit_expr(out, arg0);
        out.print(")");
        out.print(".length())");
        break;
      case 'ord':
        out.print("(unsigned char)(");
        emit_expr(out, arg0);
        out.print(".c_str()[");
        if (nargs > 1)
            emit_expr(out, arg1);
        else
            out.print("0");
        out.print("])");
        break;
      case 'chr':
        out.print("WxxObjectPtr(" + Type_String + "(1, int(");
        emit_expr(out, arg0);
        out.print(")))");
        break;
      case 'indexof':
        out.print(Type_Int + "((");
        emit_expr(out, arg0);
        out.print(").find(");
        emit_expr(out, arg1);
        if (nargs > 2) {
            out.print(", ");
            emit_expr(out, arg2);
        }
        out.print("))");
        break;
      case 'substr':
        type0 = arg0.checkresult();
        if (type0 != REGstring)
            out.print(Type_String + "(");
        emit_expr(out, arg0);
        if (type0 != REGstring)
            out.print(")");
        out.print(".substr(");
        emit_expr(out, arg1);
        if (nargs > 2) {
            out.print(", ");
            emit_expr(out, arg2);
        }
        out.print(")");
        break;
      case 'join':
        emit_callbuiltin_simple_2(out, "wxx_join", arg0, arg1);
        break;

      case 'downcase':
        // Fake implementation, just cast to string the argument
        out.print(Type_String);
        emit_expr(out, arg0);
        break;

      case 'push':
        emit_expr(out, arg0);
        out.print(".push");
        emit_expr(out, arg1);
        break;
      case 'split':
        emit_callbuiltin_simple_2(out, "wxx_split", arg0, arg1);
        break;
      case 'die':
        out.print("wxx_error(");
        emit_expr(out, arg0);
        out.print(")");
        break;
      case 'Error':
        out.print("wxx_error(");
        emit_expr(out, arg0);
        if (nargs > 1) {
            out.print(", ");
            emit_expr(out, arg1);
        }
        if (nargs > 2) {
            out.print(", ");
            emit_expr(out, arg2);
        }
        out.print(")");
        break;
      case 'open':
        out.print("WxxObjectPtr((new WxxFileHandle())->open(");
        emit_expr(out, arg0);
        if (nargs > 1) {
            out.print(", ");
            emit_expr(out, arg1);
        }
        out.print("))");
        break;
      case 'loadlib':
        emit_callbuiltin_simple(out, 'wxx_loadlib', arg0);
        break;
      case 'dlfunc':
        var sig = arg2;
        if (! sig.isstringliteral())
            throw Error("dlfunc siganture must be compile time constant");
        int nsigargs = length(sig.strval.rawstring()) - 1;
        string csig = ncisigtoc(sig.strval.rawstring());

        out.print("wxx_dlfunc<" + csig + ", " + string(nsigargs) + ">(");
        emit_expr(out, arg0);
        out.print(", ");
        emit_expr(out, arg1);
        out.print(")");
        break;
      case 'spawnw':
        emit_callbuiltin_simple(out, 'wxx_spawnw', arg0);
        break;
      case 'exit':
        emit_callbuiltin_simple(out, 'exit', arg0);
        break;
      case 'sin':
      case 'cos':
      case 'tan':
      case 'asin':
      case 'acos':
      case 'atan':
      case 'exp':
      case 'sqrt':
        emit_callbuiltin_simple(out, name, arg0);
        break;
      case 'ln':
        emit_callbuiltin_simple(out, 'log', arg0);
        break;

      // Unsupported, always return null
      case 'load_bytecode':
      case 'load_language':
      case 'compreg':
      case 'getinterp':
        out.print("winxedxxnull");
        break;

      // Unimplemented, just to allow some testing
      case 'clone':
        emit_expr(out, arg0);
        break;

      // Unimplemented, just to allow some testing
      case 'get_class':
        out.print("winxedxxnull");
        break;

      case 'escape':
        emit_callbuiltin_simple(out, 'wxx_escape', arg0);
        break;

      // Unimplemented, just to allow some testing
      case 'unescape':
        emit_expr(out, arg0);
        break;

      default:
        WxxUnsupported(expr, "builtin " + name);
    }
}

function emit_callargs(out, args)
{
    out.print("WinxedXX::WxxObjectArray()");
    int nargs = args == null ? 0 : args.numargs();
    for (int i = 0; i < nargs; ++i) {
        out.print(".push(");
        var arg = args.getfreearg(i);
        emit_expr(out, arg);
        out.print(")");
    }
}

function emit_CallMemberExpr(out, callexpr)
{
    var funref = callexpr.funref;
    var args = callexpr.args;
    int nargs = args == null ? 0 : args.numargs();

    if (callexpr.subid != null) {
        out.print(callexpr.subid);
        out.print("(");
        emit_callargs(out, args);
    }
    else {
        var left = funref.left;
        int is_var = left.checkresult() == REGvar;
        if (!is_var)
            out.print("WxxObjectPtr(");
        emit_expr(out, funref.left);
        if (!is_var)
            out.print(")");
        out.print(".call_method(\"");
        out.print(funref.right.getidentifier());
        out.print("\"");
        if (nargs > 0) {
            out.print(", ");
            emit_callargs(out, args);
        }
    }
    out.print(")");
}

function emit_CallExpr(out, callexpr)
{
    var funref = callexpr.funref;
    var args = callexpr.args;
    if (! funref.isidentifier())
        WxxUnsupported(funref);

    if ((callexpr instanceof CallMemberExpr) && callexpr.subid != null)
        out.print(callexpr.subid);
    else {
        string callname = funref.getName();
        out.print(callname);
    }
    out.print("(");
    emit_callargs(out, args);
    out.print(")");
}

function emit_arrayexpr(out, expr)
{
    var values = expr.values;
    int nvalues = values == null ? 0 : elements(values);
    out.print("WxxObjectPtr(&((* new WxxObjectArray())");
    int i;
    for (i = 0; i < nvalues; ++i) {
        out.print(".push");
        emit_expr(out, values[i]);
    }
    out.print("))");
}

function emit_hashexpr(out, expr)
{
    var keys = expr.keys;
    var values = expr.values;
    int n = elements(keys);
    out.print("WxxObjectPtr(&((* new WxxHash())");
    int i;
    for (i = 0; i < n; ++i) {
        out.print(".set(");
        emit_expr(out, keys[i]);
        out.print(", ");
        emit_expr(out, values[i]);
        out.print(")");
    }
    out.print("))");
}

function emit_FunctionExpr(out, expr)
{
    // For initial tests
    out.print("winxedxxnull");
}

function emit_newexpr(out, expr)
{
    var value = expr.value;
    if (value.isidentifier()) {
        var initializer = expr.initializer;
        int numinits = initializer == null ? -1 : initializer.numargs();
        out.print("wxx_new(\"" + string(value) + "\"");
        if (numinits >= 0) {
            out.print(", ");
            emit_callargs(out, initializer);
        }
        out.print(")");
    }
    else if (value.isstring()) {
        string name = value.getasquoted();
        switch (name) {
          case 'FileHandle':
            out.print("WxxObjectPtr(new WxxFileHandle())");
            break;
          default:
            out.print("WxxObjectPtr(new WxxInstance(\"" + name + "\"))");
        }
    }
    else
        WxxUnsupported(expr);
}

function emit_NewIndexedExpr(out, expr)
{
    var key = expr.nskey.key;
    if (elements(key) != 1)
        WxxUnsupported(expr, "supported only with keys length == 1");

    // TESTING
    string name = key[0];
    out.print("WxxObjectPtr(new WxxInstance(\"" + name + "\"))");
}

function emit_assignexpr(out, assignexpr)
{
    var lexpr = assignexpr.lexpr;
    var rexpr = assignexpr.rexpr;
    string ltype = lexpr.checkresult();
    string rtype = rexpr.checkresult();
    if (lexpr instanceof IdentifierExpr) {
        out.print(lexpr.name);
        out.print(" = ");
        switch {
          case ltype == REGstring && rtype == REGint:
            out.print('wxx_int_to_string');
            emit_expr(out, rexpr);
            break;
          case ltype == REGint && rtype == REGstring:
            out.print('wxx_string_to_int');
            emit_expr(out, rexpr);
            break;
          case ltype == REGstring && rtype == REGfloat:
            out.print('wxx_num_to_string');
            emit_expr(out, rexpr);
            break;
          case ltype == REGfloat && rtype == REGstring:
            out.print('wxx_string_to_num');
            emit_expr(out, rexpr);
            break;
          default:
            // Coerce result type to avoid ambiguities
            out.print(generatedType(lexpr.checkresult()));
            emit_expr(out, rexpr);
        }
    }
    else if (lexpr instanceof MemberExpr) {
        emit_expr(out, lexpr.left);
        string ident = lexpr.right.getidentifier();
        out.print(".set_attr_str(\"" + ident + "\",");
        emit_expr(out, rexpr);
        out.print(")");
    }
    else if (lexpr instanceof MemberRefExpr) {
        // Fake implementation to allow some testing.
        out.print("winxedxxnull");
    }
    else if (lexpr instanceof IndexExpr) {
        var left = lexpr.left;
        emit_expr(out, left);
        var arg = lexpr.args.getarg(0);
        out.print(".set_pmc_keyed(");
        emit_expr(out, arg);
        out.print(", ");
        emit_expr(out, rexpr);
        out.print(")");
    }
    else
        WxxUnsupported(lexpr);
}

function emit_assigntoexpr(out, expr)
{
    var lexpr = expr.lexpr;
    var rexpr = expr.rexpr;
    if (lexpr instanceof IdentifierExpr) {
        out.print(lexpr.name);
        out.print(".set");
        emit_expr(out, rexpr);
    }
    else if (lexpr instanceof MemberExpr) {
        emit_expr(out, lexpr.left);
        string ident = lexpr.right.getidentifier();
        out.print(".get_attr_str(\"" + ident + "\").set");
        emit_expr(out, rexpr);
    }
    else if (lexpr instanceof MemberRefExpr) {
        // Fake implementation to allow some testing.
        out.print("winxedxxnull");
    }
    else
        WxxUnsupported(lexpr);
}

function emit_instanceofexpr(out, instanceofexpr)
{
    var lexpr = instanceofexpr.lexpr;
    var checked = instanceofexpr.checked;
    out.print("wxx_instanceof(");
    emit_expr(out, lexpr);
    out.print(", ");
    if (checked instanceof ClassSpecifierStr)
        out.print('"' + string(checked.name) + '"');
    else if (checked instanceof ClassSpecifierId)
        out.print('"' + string(checked.last()) + '"');
    else
        out.print('"' + string(tokstringtoxx(checked)) + '"');
    out.print(")");
}

function emit_addtoexpr(out, assignexpr)
{
    var lexpr = assignexpr.lexpr;
    if (lexpr instanceof IdentifierExpr) {
        out.print(lexpr.name);
        out.print(" += ");
        if (lexpr.checkresult() == REGstring)
            out.print(Type_String);
        emit_expr(out, assignexpr.rexpr);
    }
    else
        WxxUnsupported(lexpr);
}

function emit_addexpr(out, expr)
{
    var lexpr = expr.lexpr;
    var rexpr = expr.rexpr;
    emit_expr(out, lexpr);
    out.print(" + ");
    emit_expr(out, rexpr);
}

function emit_subexpr(out, expr)
{
    var lexpr = expr.lexpr;
    var rexpr = expr.rexpr;
    emit_expr(out, lexpr);
    out.print(" - ");
    emit_expr(out, rexpr);
}

function emit_RepeatString(out, expr)
{
    var lexpr = expr.lexpr;
    var rexpr = expr.rexpr;
    out.print("wxx_repeat_string(");
    emit_expr(out, lexpr);
    out.print(", ");
    emit_expr(out, rexpr);
    out.print(")");
}

function emit_mulexpr(out, expr)
{
    var lexpr = expr.lexpr;
    var rexpr = expr.rexpr;
    emit_expr(out, lexpr);
    out.print(" * ");
    emit_expr(out, rexpr);
}

function emit_divexpr(out, expr)
{
    var lexpr = expr.lexpr;
    var rexpr = expr.rexpr;
    emit_expr(out, lexpr);
    out.print(" / ");
    emit_expr(out, rexpr);
}

function emit_concatstring(out, concatstr)
{
    var values = concatstr.values;
    emit_expr(out, values[0]);
    int n = elements(values);
    for (int i = 1; i < n; ++i) {
        out.print(" + ");
        emit_expr(out, values[i]);
    }
}

function emit_nullchecker(out, expr)
{
    if (! expr.positive)
        out.print("!");
    out.print("(");
    out.print("wxx_isnull");
    emit_expr(out, expr.expr);
    out.print(")");
}

function emit_opnot(out, expr)
{
    out.print("!");
    emit_expr(out, expr.subexpr);
}

function emit_OpBinNot(out, expr)
{
    out.print("~");
    emit_expr(out, expr.subexpr);
}

function emit_ZeroCheckerExpr(out, expr)
{
    out.print("(");
    emit_expr(out, expr.expr);
    out.print(expr.positive ? "=" : "!");
    out.print("= 0)");
}

function emit_OpEqualExpr(out, expr)
{
    var lexpr = expr.lexpr;
    var rexpr = expr.rexpr;
    if (lexpr.checkresult() == REGvar && rexpr.checkresult() == REGvar) {
        if (! expr.positive)
            out.print("!");
        out.print("(");
        emit_expr(out, lexpr);
        out.print(".is_equal");
        emit_expr(out, rexpr);
        out.print(")");
    }
    else
        emit_commonop(out, expr, expr.positive ? "==" : "!=");
}

function emit_OpSameExpr(out, expr)
{
    var lexpr = expr.lexpr;
    var rexpr = expr.rexpr;
    if (lexpr.checkresult() != REGvar || rexpr.checkresult() != REGvar)
        WxxUnsupported(expr, "unsupported usage of ===");
    if (! expr.positive)
        out.print("!");
    out.print("(");
    emit_expr(out, rexpr);
    out.print(".is_same(");
    emit_expr(out, lexpr);
    out.print("))");
}

function emit_commonop(out, expr, string opstr)
{
    emit_expr(out, expr.lexpr);
    out.print(" ");
    out.print(opstr);
    out.print(" ");
    emit_expr(out, expr.rexpr);
}

function emit_boolorexpr(out, lessexpr)
{
    out.print("wxx_boolor(");
    emit_expr(out, lessexpr.lexpr);
    out.print(", ");
    emit_expr(out, lessexpr.rexpr);
    out.print(")");
}

function emit_boolandexpr(out, lessexpr)
{
    out.print("wxx_booland(");
    emit_expr(out, lessexpr.lexpr);
    out.print(", ");
    emit_expr(out, lessexpr.rexpr);
    out.print(")");
}

function emit_conditionalexpr(out, expr)
{
    emit_expr(out, expr.condition.condexpr);
    out.print(" ? ");
    string ttrue = expr.etrue.checkresult();
    string tfalse = expr.efalse.checkresult();
    emit_expr(out, expr.etrue);
    out.print(" : (");
    if (ttrue != tfalse)
        out.print("(" + string(generatedType(ttrue)) + ")");
    emit_expr(out, expr.efalse);
    out.print(")");
}

function emit_identifierexpr(out, expr)
{
    string name = expr.name;
    if (name == "null")
        out.print("winxedxxnull");
    else
        out.print(name);
}

function emit_indexexpr(out, expr)
{
    var left = expr.left;
    emit_expr(out, left);
    var arg = expr.args.getarg(0);
    if (left.checkresult() == REGstring) {
        out.print('.substr(');
        emit_expr(out, arg);
        out.print(', 1)');
    }
    else {
        out.print(".get_pmc_keyed");
        emit_expr(out, arg);
    }
}

function emit_StringIndexExpr(out, expr)
{
    var left = expr.left;
    emit_expr(out, left);
    var arg = expr.arg;
    out.print('.substr(');
    emit_expr(out, arg);
    out.print(', 1)');
}

function emit_OpExistsExpr(out, expr)
{
    var subexpr = expr.subexpr;
    if (! (subexpr instanceof IndexExpr) || expr.checkresult() == REGstring)
        WxxUnsupported(expr, "exits with invalid operator");

    // Fake implementation to allow some testing
    emit_expr(out, subexpr.left);
    var arg = subexpr.args.getarg(0);
    out.print(".exists");
    emit_expr(out, arg);
}

function emit_memberexpr(out, expr)
{
    emit_expr(out, expr.left);
    out.print(".get_attr_str(\"");
    out.print(expr.right.getidentifier());
    out.print("\")");
}

function emit_MemberRefExpr(out, expr)
{
    emit_expr(out, expr.left);
    out.print(".get_attr_str(");
    emit_expr(out, expr.right);
    out.print(")");
}

function emit_expr(out, expr)
{
    out.print("(");

    if (expr instanceof CallBuiltinExpr)
        emit_callbuiltinexpr(out, expr);
    else if (expr instanceof CallMemberExpr)
        emit_CallMemberExpr(out, expr);
    else if (expr instanceof CallExpr)
        emit_CallExpr(out, expr);
    else if (expr instanceof OpAssignExpr)
        emit_assignexpr(out, expr);
    else if (expr instanceof OpAssignToExpr)
        emit_assigntoexpr(out, expr);
    else if (expr instanceof OpAddToExpr)
        emit_addtoexpr(out, expr);
    else if (expr instanceof IdentifierExpr)
        emit_identifierexpr(out, expr);
    else if (expr instanceof IntegerLiteral)
        out.print(expr.getIntegerValue());
    else if (expr instanceof FloatLiteral)
        out.print(expr.numval);
    else if (expr instanceof StringLiteral) {
        out.print(Type_String + '("');
        out.print(stringtoxx(expr));
        out.print('")');
    }
    else if (expr instanceof NewExpr)
        emit_newexpr(out, expr);
    else if (expr instanceof NewIndexedExpr)
        emit_NewIndexedExpr(out, expr);
    else if (expr instanceof ArrayExpr)
        emit_arrayexpr(out, expr);
    else if (expr instanceof HashExpr)
        emit_hashexpr(out, expr);
    else if (expr instanceof FunctionExpr) {
        emit_FunctionExpr(out, expr);
    }
    else if (expr instanceof OpNotExpr)
        emit_opnot(out, expr);
    else if (expr instanceof OpBinNotExpr)
        emit_OpBinNot(out, expr);
    else if (expr instanceof NullCheckerExpr)
        emit_nullchecker(out, expr);
    else if (expr instanceof OpInstanceOfExpr)
        emit_instanceofexpr(out, expr);
    else if (expr instanceof OpPreIncExpr) {
        out.print('++');
        emit_expr(out, expr.subexpr);
    }
    else if (expr instanceof OpPreDecExpr) {
        out.print('--');
        emit_expr(out, expr.subexpr);
    }
    else if (expr instanceof OpPostIncExpr) {
        emit_expr(out, expr.subexpr);
        out.print('++');
    }
    else if (expr instanceof OpPostDecExpr) {
        emit_expr(out, expr.subexpr);
        out.print('--');
    }
    else if (expr instanceof OpUnaryMinusExpr) {
        out.print('-');
        emit_expr(out, expr.subexpr);
    }
    else if (expr instanceof OpAddExpr)
        emit_addexpr(out, expr);
    else if (expr instanceof OpSubExpr)
        emit_subexpr(out, expr);
    else if (expr instanceof RepeatString)
        emit_RepeatString(out, expr);
    else if (expr instanceof OpMulExpr)
        emit_mulexpr(out, expr);
    else if (expr instanceof OpDivExpr)
        emit_divexpr(out, expr);
    else if (expr instanceof ConcatString)
        emit_concatstring(out, expr);
    else if (expr instanceof ZeroCheckerExpr)
        emit_ZeroCheckerExpr(out, expr);
    else if (expr instanceof OpEqualExpr)
        emit_OpEqualExpr(out, expr);
    else if (expr instanceof OpSameExpr)
        emit_OpSameExpr(out, expr);
    else if (expr instanceof OpLessEqualExpr)
        emit_commonop(out, expr, "<=");
    else if (expr instanceof OpLessExpr)
        emit_commonop(out, expr, "<");
    else if (expr instanceof OpGreaterExpr)
        emit_commonop(out, expr, ">");
    else if (expr instanceof OpGreaterEqualExpr)
        emit_commonop(out, expr, ">=");
    else if (expr instanceof OpBoolOrExpr)
        emit_boolorexpr(out, expr);
    else if (expr instanceof OpBoolAndExpr)
        emit_boolandexpr(out, expr);
    else if (expr instanceof OpBinOrExpr)
        emit_commonop(out, expr, '|');
    else if (expr instanceof OpBinAndExpr)
        emit_commonop(out, expr, '&');
    else if (expr instanceof OpBinXorExpr)
        emit_commonop(out, expr, '^');
    else if (expr instanceof OpShiftrightExpr)
        emit_commonop(out, expr, '>>');
    else if (expr instanceof OpShiftleftExpr)
        emit_commonop(out, expr, '<<');
    else if (expr instanceof OpModExpr)
        emit_commonop(out, expr, "%");
    else if (expr instanceof OpCModExpr)
        emit_commonop(out, expr, "%");
    else if (expr instanceof OpConditionalExpr)
        emit_conditionalexpr(out, expr);
    else if (expr instanceof MemberExpr)
        emit_memberexpr(out, expr);
    else if (expr instanceof MemberRefExpr) {
        emit_MemberRefExpr(out, expr);
    }
    else if (expr instanceof IndexExpr)
        emit_indexexpr(out, expr);
    else if (expr instanceof StringIndexExpr)
        emit_StringIndexExpr(out, expr);
    else if (expr instanceof OpExistsExpr)
        emit_OpExistsExpr(out, expr);
    else
        WxxUnsupported(expr);
    out.print(")");
}

function emit_exprst(out, exprst)
{
    var expr = exprst.expr;
    emit_expr(out, expr);
}

function emit_conststatement(out, st)
{
}

function emit_varstatement(out, st)
{
    out.print("WxxObjectPtr ");
    out.print(st.name);
    var init = st.init;
    if (init != null) {
        out.print(" = ");
        emit_expr(out, init);
    }
}

function emit_nativetypestatement(out, st, string simpletype, string nullinit)
{
    string name = st.name;
    var init = st.init;

    out.print(simpletype);
    out.print(" ");
    out.print(name);
    if (init == null) {
        out.print(" = ");
        out.print(nullinit);
    }
    else {
        string inittype = generatedType(init.checkresult());
        out.print(" = (");
        switch {
          case simpletype == inittype:
            break;
          case simpletype == Type_String:
            switch (inittype) {
              case Type_Int:
                out.print("wxx_int_to_string");
                break;
              case Type_Num:
                out.print("wxx_num_to_string");
                break;
            }
            break;
        }
        emit_expr(out, init);
        out.print(")");
    }
}

function emit_nativearraystatement(out, st, string arraytype)
{
    string name = st.name;
    var init = st.initarray;

    out.print("WxxObjectPtr ");
    out.print(name);
    out.print("(&((*new Wxx");
    out.print(arraytype);
    out.print("Array())");
    if (init != null) {
        for (var item in init) {
            out.print(".push(");
            emit_expr(out, item);
            out.print(")");
        }
    }
    out.print("))");
}

function emit_labelstatement(out, labelst)
{
    out.print(labelst.name);
    out.print(":\n");
}

function emit_breakstatement(out, gotost)
{
    out.print("break");
}

function emit_ContinueStatement(out, gotost)
{
    out.print("continue");
}

function emit_gotostatement(out, gotost)
{
    out.print("goto ");
    out.print(gotost.label);
}

function emit_ifstatement(out, ifst)
{
    var truebranch = ifst.truebranch;
    var falsebranch = ifst.falsebranch;
    out.print('if ');
    emit_expr(out, ifst.condexpr);
    out.print("\n{\n");
    if (! truebranch.isempty())
        emit_statement(out, truebranch);
    if (! falsebranch.isempty()) {
        out.print("} else {\n");
        emit_statement(out, falsebranch);
    }
    out.print("}\n");
}

function emit_switchstatement(out, switchst)
{
    var case_value = switchst.case_value;
    var case_st = switchst.case_st;
    out.print("do {\nWxxObjectPtr wxxswvar = ");
    emit_expr(out, switchst.condition);
    out.print(";\n");

    int n = elements(case_st);
    for (int i = 0; i < n; ++i) {
        var caseval = case_value[i];
        out.print ("if (wxxswvar == ");
        emit_expr(out, caseval);
        out.print(") {\n");
        int nst = elements(case_st[i]);
        int j;
        for (j = 0; j < nst; ++j)
            emit_statement(out, case_st[i][j]);
        out.print("}\n");
    }
    var default_st = switchst.default_st;
    int nst = elements(default_st);
    int j;
    for (j = 0; j < nst; ++j)
        emit_statement(out, default_st[j]);

    out.print("} while (false)\n");
}

function emit_SwitchCaseStatement(out, switchst)
{
    var case_value = switchst.case_value;
    var case_st = switchst.case_st;
    int n = elements(case_st);

    out.print("do {\n");

    for (int i = 0; i < n; ++i) {
        var caseval = case_value[i];
        out.print ("if ");
        emit_expr(out, caseval);
        out.print(" {\n");
        int nst = elements(case_st[i]);
        int j;
        for (j = 0; j < nst; ++j)
            emit_statement(out, case_st[i][j]);
        out.print("}\n");
    }
    var default_st = switchst.default_st;
    int nst = elements(default_st);
    int j;
    for (j = 0; j < nst; ++j)
        emit_statement(out, default_st[j]);

    out.print("} while (false)\n");
}

function emit_whilestatement(out, whilest)
{
    out.print('while ');
    emit_expr(out, whilest.condexpr);
    out.print("\n{\n");
    emit_statement(out, whilest.body);
    out.print("}\n");
}

function emit_dostatement(out, dost)
{
    out.print("do {\n");
    emit_statement(out, dost.body);
    out.print("} while ");
    emit_expr(out, dost.condexpr);
}

function emit_trystatement(out, tryst)
{
    out.print("try\n{\n");
    emit_statement(out, tryst.stry);
    out.print("}\ncatch (");
    if (tryst.exname == null)
        out.print("...");
    else {
        out.print("WxxObjectPtr &");
        out.print(string(tryst.exname));
    }
    out.print(")\n{\n");
    emit_statement(out, tryst.scatch);
    out.print("}\n");
}

function emit_throwstatement(out, throwst)
{
    out.print("throw ");
    emit_expr(out, throwst.excep);
}

function emit_forstatement(out, forst)
{
    var initializer = forst.initializer;
    var condexpr = forst.condexpr;
    var iteration = forst.iteration;
    out.print("for (");
    if (initializer != null)
        emit_statement(out, initializer);
    else
        out.print(";");
    if (condexpr != null)
        emit_expr(out, forst.condexpr);
    out.print(";");
    if (iteration != null)
        emit_expr(out, forst.iteration);
    out.print(") {\n");
    emit_statement(out, forst.body);
    out.print("}\n");
}

function emit_foreachstatement(out, forst)
{
    var varname = forst.varname;
    var container = forst.container;
    out.print("{\nWxxObjectPtr wxx_it = ");
    string ctype = container.checkresult();
    if (ctype == REGstring)
        out.print("WxxObjectPtr(");
    emit_expr(out, container);
    if (ctype == REGstring)
        out.print(")");

    out.print(".get_iter();\nwhile (bool(wxx_it)) {\n");
    string type = forst.deftype == null ? '' : string(forst.deftype);

    if (indexof("INSP", type) >= 0)
        out.print(string(generatedType(type)) + " ");

    out.print(varname);
    out.print(" = wxx_it.shift_pmc();\n");
    emit_statement(out, forst.body);
    out.print("}\n}\n");
}

function emit_returnstatement(out, returnst)
{
    var values = returnst.values;
    int nargs = values == null ? 0 : int(values.numargs());
    switch (nargs) {
      case 0:
        out.print("return WxxObjectPtr()");
        break;
      case 1:
        var expr = values.getfreearg(0);
        out.print("return ");
        emit_expr(out, expr);
        break;
      default:
        WxxUnsupported(returnst);
    }
}

function emit_compoundstatement(out, compound)
{
    var stlist = compound.statements;
    int nst = elements(stlist);
    int i;
    out.print("{\n");
    for (i = 0; i < nst; ++i) {
        var st = stlist[i];
        emit_statement(out, st);
    }
    out.print("}\n");
}

function emit_multistatement(out, mst)
{
    var stlist = mst.statements;
    int nst = elements(stlist);
    int i;
    for (i = 0; i < nst; ++i) {
        var st = stlist[i];
        emit_statement(out, st);
    }
}

function emit_UsingStatement(out, st)
{
    if (st.subid != null) {
        var path = st.path;
        string name = path[-1];
        out.print('static WxxObjectPtr (*const ');
        out.print(name);
        out.print(")(const WxxObjectArray &wxx_fun_args) =  ");
        out.print(st.subid);
    }
}

function emit_statement(out, st)
{
    if (st instanceof MultiStatement)
        emit_multistatement(out, st);
    else if (st instanceof CompoundStatement)
        emit_compoundstatement(out, st);
    else if (st instanceof ConstStatement)
        emit_conststatement(out, st);
    else if (st instanceof IntStatement)
        emit_nativetypestatement(out, st, Type_Int, "0");
    else if (st instanceof FloatStatement)
        emit_nativetypestatement(out, st, Type_Num, "0.0");
    else if (st instanceof StringStatement)
        emit_nativetypestatement(out, st, Type_String, '""');
    else if (st instanceof IntArrayStatement)
        emit_nativearraystatement(out, st, "Integer");
    else if (st instanceof FloatArrayStatement)
        emit_nativearraystatement(out, st, "Float");
    else if (st instanceof StringArrayStatement)
        emit_nativearraystatement(out, st, "String");
    else if (st instanceof VarStatement)
        emit_varstatement(out, st);
    else if (st instanceof LabelStatement)
        emit_labelstatement(out, st);
    else if (st instanceof BreakStatement)
        emit_breakstatement(out, st);
    else if (st instanceof ContinueStatement)
        emit_ContinueStatement(out, st);
    else if (st instanceof GotoStatement)
        emit_gotostatement(out, st);
    else if (st instanceof IfStatement)
        emit_ifstatement(out, st);
    else if (st instanceof SwitchStatement)
        emit_switchstatement(out, st);
    else if (st instanceof SwitchCaseStatement)
        emit_SwitchCaseStatement(out, st);
    else if (st instanceof WhileStatement)
        emit_whilestatement(out, st);
    else if (st instanceof DoStatement)
        emit_dostatement(out, st);
    else if (st instanceof TryStatement)
        emit_trystatement(out, st);
    else if (st instanceof ThrowStatement)
        emit_throwstatement(out, st);
    else if (st instanceof ForStatement)
        emit_forstatement(out, st);
    else if (st instanceof ForeachStatement)
        emit_foreachstatement(out, st);
    else if (st instanceof ReturnStatement)
        emit_returnstatement(out, st);
    else if (st instanceof ExprStatement)
        emit_exprst(out, st);
    else if (st instanceof EmptyStatement)
        /* Do nothing */ ;
    else if (st instanceof ExternStatement)
        /* Do nothing */ ;
    else if (st instanceof StaticStatement)
        /* Do nothing */ ;
    else if (st instanceof UsingStatement)
        emit_UsingStatement(out, st);
    else if (st instanceof UsingNamespaceStatement)
        /* Do nothing */ ;
    else
        WxxUnsupported(st);

    if (! (st instanceof CompoundStatement))
        out.print(";\n");
}

function emit_declare_function(out, funst)
{
    string name = funst.name;
    out.print('WxxObjectPtr ');
    out.print(name);
    out.print("(const WxxObjectArray &wxx_fun_args);\n");
}

function emit_declare_function_subid(out, funst, key)
{
    string name = funst.name;
    if (funst.subid != null) {
        out.print('static WxxObjectPtr (*const ');
        out.print(funst.subid);
        out.print(")(const WxxObjectArray &wxx_fun_args) =  &");
        if (elements(key) > 0)
            out.print(join("::", key) + "::");
        out.print(name);
        out.print(";\n");
    }
}

//**********************************************************************

const string DATA = '__data';
const string DECREFDATA = DATA + "->decref();";

function declareFunctionData(string name)
{
    return "struct " + name + " : public WinxedXX::WxxFunctionVars";
}

function declareDataInstance(string name)
{
    return name + " *__data = new " + name + ";\n";
}

function declareDataVar(out, string varname, string vartype)
{
    out.print(generatedType(vartype));
    out.print(" ");
    out.print(varname);
    //out.print(";\n");
}

function getArgValue(out, int i)
{
    out.print("(wxx_fun_args[");
    out.print(i);
    out.print("]);\n");
}

function setDataVarFromArg(out, string name, string type, int i)
{
    out.print(DATA + "->");
    out.print(name);
    out.print(" = ");
    if (type == REGstring)
        out.print(Type_String);
    getArgValue(out, i);
}

function declareReferenceToData(out, string name, string type)
{
    out.print(generatedType(type));
    out.print(" &");
    out.print(name);
    out.print(" = " + DATA + "->" + name);
    out.print(";\n");
}

function foreachparam(params, funst, func)
{
    foreach(params,
        function(param)
        {
            string name = param.name;
            string type = funst.getvar(name).gettype();
            func(name, type);
        }
    );
}

function emit_FunctionStatement(out, funst)
{
    string name = funst.name;
    int ismethod = funst.ismethod();
    int haslocals = funst.localfun != null;

    //haslocals = true; // Testing

    out.print("\n// function " + name + "\n\n");

    int isconstructor = false;
    if (ismethod) {
        var cl = funst.owner;
        string clname = cl.name;
        if (clname == name)
            isconstructor = true;
    }
    string newname = isconstructor ? "__Winxedxx_constructor" : name;
    string dataname = newname + DATA;
    var params = funst.params;
    int nparams = params == null ? 0 : elements(params);

    if (haslocals) {
        out.print(declareFunctionData(dataname));
        out.print(" \n{\n");
        foreachparam(params, funst,
           function(string name, string type)
           {
               declareDataVar(out, name, type);
               out.print(";\n");
           }
        );
        var locals = funst.body.locals;
        foreach(locals,
            function(string name)
            {
                var local = locals[name];
                if (local.isconst())
                    return;
                declareDataVar(out, name, local.type);
                out.print(";\n");
            }
        );
        out.print("};\n\n");
    }

    if (ismethod)
        out.print("static ");

    out.print('WxxObjectPtr ');
    out.print(newname);
    out.print("(");

    if (ismethod)
        out.print("WxxObjectPtr &self, ");
    out.print("const WxxObjectArray &wxx_fun_args");
    out.print(")\n{\n");

    if (haslocals) {
        out.print(declareDataInstance(dataname));
        for (int i = 0; i < nparams; ++i) {
            var param = params[i];
            string name = param.name;
            setDataVarFromArg(out, name, funst.getvar(name).gettype(), i);
        }
        foreachparam(params, funst,
            function(string name, string type)
            {
                declareReferenceToData(out, name, type);
            }
        );
    }
    else
    {
        for (int i = 0; i < nparams; ++i) {
            var param = params[i];
            string name = param.name;
            declareDataVar(out, name, funst.getvar(name).gettype());
            getArgValue(out, i);
        }
    }

    // Get body. Should be a CompundStatement
    if (haslocals)
        out.print("try {\n");
    var body = funst.body;
    emit_statement(out, body);
    if (haslocals)
        out.print("} catch (...) {" + DECREFDATA + " throw; }\n " +
                DECREFDATA + "\n");
    out.print("\nreturn winxedxxnull;\n\n} // function " + name + "\n\n");
}

//**************************************************************

function emit_classst(out, clst)
{
    string name = clst.name;
    var members = clst.members;
    var functions = clst.functions;

    out.print("\n// class " + name + "\n\n");

    out.print("class ");
    out.print(name);
    out.print("\n{\n");

    int nfunctions = elements(functions);
    int i;
    foreach(functions,
        function(f) { emit_FunctionStatement(out, f); }
    );

    out.print(<<:CLINIT
static WxxClass * init_class()
{
    WxxClass *cl = new WxxClass(
CLINIT:>>
    );
    out.print('"' + name + '"');
    out.print(<<:CLINIT
        );
CLINIT:>>
    );
    for (i = 0; i < elements(members); ++i) {
        string member = members[i];
        out.print("cl->addattribute(\"" + member + "\");\n");
    }
    for (i = 0; i < nfunctions; ++i) {
        var fun = functions[i];
        string fname = fun.name;
        string cxxname = fname == name  ? "__Winxedxx_constructor" : fname;
        out.print("cl->addfunction(\"" + fname +
                "\", &" + name + "::" + cxxname + ");\n");
    }

    out.print("return cl;\n}\n");

    out.print("static WxxClass *clreg;\n};\n");

    out.print("WxxClass * " + name + "::clreg = " + name + "::init_class();");
}

function emit_namespacest(out, ns)
{
    if (! (ns instanceof RootNamespace)) {
        out.print("namespace ");
        out.print(ns.name);
        out.print("\n{\n");
    }

    for (var item in ns.items) {
        if (item instanceof FunctionStatement)
            emit_FunctionStatement(out, item);
        else if (item instanceof NamespaceStatement)
            emit_namespacest(out, item);
        else if (item instanceof ClassStatement)
            emit_classst(out, item);
        else if (item instanceof MultiStatement)
            emit_statement(out, item);
        else if (item instanceof ConstStatement)
            /* ignored */;
        else
            WxxUnsupported(item);
    }
    if (! (ns instanceof RootNamespace))
        out.print("\n}\n");
}

function emit_declare_namespacest(out, ns)
{
    if (! (ns instanceof RootNamespace)) {
        out.print("namespace ");
        out.print(ns.name);
        out.print("\n{\n");
    }

    // Declare functions
    for (var fun in ns.functions) {
        if (fun instanceof Winxed.Compiler.Builtin)
            continue;
        emit_declare_function(out, fun);
    }

    // Declare child namespaces
    for (var childns in ns.namespaces)
        emit_declare_namespacest(out, childns);

    if (! (ns instanceof RootNamespace))
        out.print("\n}\n");
}

function emit_declare_subid(out, ns, key[optional], seen[optional])
{
    if (key == null) {
        string newkey[];
        key = newkey;
        // This is a bit hackish for anow
        seen = {};
        seen =: 5;
        seen.set_value_type(1);
    }
    else {
        key = clone(key);
        push(key, ns.name);
    }
    // Declare own functions
    for (var fun in ns.functions) {
        if (fun instanceof Winxed.Compiler.Builtin)
            continue;
        if (fun instanceof FunctionExtern)
            continue;
        if (! exists seen[fun]) {
            emit_declare_function_subid(out, fun, key);
            seen[fun] = 1;
        }
    }

    // Declare child functions
    for (var childns in ns.namespaces)
        emit_declare_subid(out, childns, key, seen);
}

function get_main(ns)
{
    int i;
    var functions = ns.functions;
    int nfunctions = elements(functions);
    for (i = 0; i < nfunctions; ++i) {
        var fun = functions[i];
        var modifiers = fun.modifiers;
        if (modifiers != null && modifiers.pick('main') != null)
            return fun.name;
        if (fun.name == 'main')
            return 'main';
    }
    return '';
}

function emit(out, parsed)
{
    var ns = parsed.rootns;
    string mainfunc = get_main(ns);

    out.print(<<:HEADER
// Generated by winxedxx

#include "winxedxx.h"

namespace WinxedXX
{

HEADER:>>
    );

    emit_declare_namespacest(out, ns);
    emit_declare_subid(out, ns);

    emit_namespacest(out, ns);

    out.print(<<:FOOTER1
} // namespace WinxedXX

FOOTER1:>>
    );

    if (mainfunc != '') {
        out.print(<<:FOOTER2
int main(int argc, char **argv)
{
    try {
        WinxedXX::WxxObjectPtr mainarg(new WinxedXX::WxxStringArray(argv));
        WinxedXX::WxxObjectPtr objresult =
                WinxedXX::
FOOTER2:>>
        );

        out.print(mainfunc);

        out.print(<<:FOOTER3
                (WinxedXX::WxxObjectArray().push(mainarg));
        int result = objresult.is_null() ? 0 : int(objresult);
        return result;
    }
    catch (WinxedXX::WxxObjectPtr &e) {
        std::cerr << "Exception caught:\n\t";
        std::cerr.flush();
        std::cerr << e.get_string() << '\n';
        return 1;
    }
    catch (const std::exception &e) {
        std::cerr << "Error: " << e.what() << '\n';
        return 1;
    }
}
FOOTER3:>>

        );
    }
    out.print("// End\n");
}

function get_winxed_compiler()
{
    // Load language module. If that fails, load the stage 2 bytecode.
    // Use the env var WINXED_PATH or set the parrot library path.
    var winxed;
    try {
        winxed = load_language('winxed');
    } catch () { }
    if (winxed == null) {
        string stagefile = 'winxedst2.pbc';
        try {
            var env = new 'Env';
            string path = env['WINXED_PATH'];
            if (path != null && path != '') {
                if (substr(path, -1) != '/')
                    path += '/';
                stagefile = path + stagefile;
            }
            load_bytecode(stagefile);
            winxed = compreg('winxed');
        }
        catch (e)
        {
            throw "Cannot load stage file '" + stagefile + "': " + string(e.message);
        }
    }
    return winxed;
}

function winxedxx_cxx(string cxxfile, string outfile)
{
    int r = spawnw( [
        "g++", "-Wall", "-O2", "-I.", "-o",
        outfile, cxxfile,
        'winxedxx_objectptr.o',
        'winxedxx_classes.o',
        'winxedxx_handle.o',
        'winxedxx_util.o',
        "-ldl"
    ] );
    r = (r >> 8) & 0xFF;
    return r;
}

function winxedxx_compile(options)
{
    var winxed = get_winxed_compiler();
    if (winxed == null)
        throw WxxError("Can't load winxed compiler");

    string sourcefile = options['sourcefile'];
    var parsed = winxed.compile_from_file(sourcefile,
        'parse':[named('target')]
    );

    string outfile = options['outfile'];
    if (outfile == null)
        outfile = '';
    string cxxfile = outfile;
    var target = options["target"];
    if (target == null || target == '')
        target = 'cxx';
    switch (target) {
      case 'exe':
      case 'run':
        if (outfile == '') {
            outfile = sourcefile + '.exe';
            cxxfile = sourcefile + '.cxx';
        }
        else
            cxxfile = outfile + '.cxx';
        break;
      case 'cxx':
        /* Nothing in particular */
        break;
      default:
        throw WxxError("Invalid target type: " + string(target));
    }
    var out = cxxfile != '' ?
        open(cxxfile, "w") :
        getstdout();
    emit(out, parsed);
    if (cxxfile != '')
        out.close();
    int r = 0;
    switch (target) {
      case 'exe':
        r = winxedxx_cxx(cxxfile, outfile);
        break;
      case 'run':
        r = winxedxx_cxx(cxxfile, outfile);
        if (r != 0)
            break;
        r = spawnw(["./" + outfile]);
        r = (r >> 8) & 0xFF;
        break;
    }
    return r;
}

//**********************************************************************

$load 'Getopt/Obj.pbc';

class WinxedxxOptions : ["Getopt", "Obj" ]
{
    var name;
    var options;
    var opts;
    function WinxedxxOptions(argv)
    {
        self.options = [
          [ "o=s",      "Object name" ],
          [ "target=s", "Set target type: cxx, exe or run. Default is cxx." ]
        ];
        for (var o in self.options)
            self.push_string(o[0]);
        self.notOptStop(1);
        self.name = argv.shift();
        self.opts = self.get_options(argv);
    }
    function getstring(string option, string default_value[optional])
    {
        var value = self.opts[option];
        return value != null ? string(value) : default_value;
    }
}

function winxedxx_get_options(argv)
{
    var options = {};
    var cloptions = new WinxedxxOptions(argv);
    options["outfile"] = cloptions.getstring("o");
    options["target"]  = cloptions.getstring("target");

    int argc = elements(argv);
    if (argc < 1)
        throw WxxError("No source file");
    options["sourcefile"] = argv.shift();
    return options;
}

function main(argv)
{
    int r = 1;
    try [handle_types(__WINXED_ERROR__)] {
        var options = winxedxx_get_options(argv);
        r = winxedxx_compile(options);
    }
    catch (e) {
        cry("Winxedxx: ", e.message);
    }
    exit(r);
}

// End
