#! winxed

// winxedxx.winxed
// C++ backend for winxed
// (C) 2011 Juli√°n Albo "NotFound"

// This code uses and abuses winxed compiler internals.
// Not a good example on how to write winxed compiler extensions,
// but there is no better way right now.

//**************************************************************

// Declare used classes

class Token;
class TokenQuoted;
class TokenSingleQuoted;

class IntegerLiteral;
class FloatLiteral;
class StringLiteral;

class IdentifierExpr;
class MemberExpr;
class IndexExpr;
class NewExpr;
class ArrayExpr;
class HashExpr;
class NullCheckerExpr;
class ConcatString;
class CallExpr;
class CallPredefExpr;

class OpPreIncExpr;
class OpPreDecExpr;
class OpPostIncExpr;
class OpPostDecExpr;
class OpAssignExpr;
class OpAssignToExpr;
class OpAddExpr;
class OpAddToExpr;
class OpSubExpr;
class OpMulExpr;
class OpDivExpr;
class OpModExpr;
class OpCModExpr;
class OpNotExpr;
class OpEqualExpr;
class OpNotEqualExpr;
class OpLessEqualExpr;
class OpGreaterEqualExpr;
class OpLessExpr;
class OpGreaterExpr;
class OpBoolAndExpr;
class OpBoolOrExpr;
class OpInstanceOfExpr;
class OpConditionalExpr;

class EmptyStatement;
class UsingStatement;
class StaticStatement;
class ExternStatement;
class ExprStatement;

class MultiStatement;
class CompoundStatement;
class VarStatement;
class IntStatement;
class FloatStatement;
class StringStatement;
class ConstStatement;
class ReturnStatement;
class LabelStatement;
class BreakStatement;
class IfStatement;
class GotoStatement;
class SwitchStatement;
class ForStatement;
class ForeachStatement;
class DoStatement;
class WhileStatement;
class TryStatement;
class ThrowStatement;

class FunctionStatement;
class ClassStatement;
class NamespaceStatement;
class RootNamespace;

//**************************************************************

function WxxUnsupported(thing, string msg[optional])
{
    if (msg == null) {
        if (thing instanceof 'String')
            msg = thing;
        else
            msg = typeof(thing);
    }
    string filename = '';
    int line = 0;
    string desc;
    try {
        var start;
        if (thing instanceof Token)
            start = thing;
        else
            start = thing.start;
        filename = start.file;
        line = start.line;
        desc = start.viewable();
    }
    catch () { }
    throw Error(filename + ":" + string(line) + ": " +
            msg + " unsupported near " + desc);
}

function tokstringtoxx(strval)
{
    string str = strval.str;
    if (strval instanceof TokenQuoted)
        return str;
    if (strval instanceof TokenSingleQuoted)
    {
        string result = '';
        int n = length(str);
        int i;
        for (i = 0 ; i < n; ++i) {
            string c = substr(str, i, 1);
            if (c ==  '"' || c == '\')
                result += '\' + c;
            else
                result += c;
        }
        return result;
    }
    throw Error('Unexpected literal string type');
}

function stringtoxx(literal)
{
    var strval = literal.strval;
    string str = strval.str;
    if (strval instanceof TokenQuoted)
        return str;
    if (strval instanceof TokenSingleQuoted)
    {
        string result = '';
        int n = length(str);
        int i;
        for (i = 0 ; i < n; ++i) {
            string c = substr(str, i, 1);
            if (c ==  '"' || c == '\')
                result += '\' + c;
            else
                result += c;
        }
        return result;
    }
    throw Error('Unexpected literal string type');
}

function nciitemtoc(string item)
{
    switch (item)
    {
      case 'i':
        return 'int';
      case 'v':
        return 'int'; // Allow void to return something
      default:
        throw Error("signature unsupported: " + item);
    }
}

function ncisigtoc(string sig)
{
    string ret = sig[0];
    string args = substr(sig, 1);
    string csig;
    csig = nciitemtoc(ret);
    csig += "(*)(";
    string sep = '';
    for (string item in args) {
        csig += sep;
        sep = ", ";
        csig += nciitemtoc(item);
    }
    csig += ")";
    return csig;
}

function emit_callpredefexpr(out, expr)
{
    var predef = expr.predef;
    string name = predef.name;
    var args = expr.args;
    int nargs = elements(args);
    int i;
    switch (name) {
      case 'string':
        switch (args[0].arg.checkresult()) {
          case 'I':
            out.print("wxx_int_to_string");
            break;
          case 'P':
            out.print("std::string");
            break;
        }
        emit_expr(out, args[0].arg);
        break;
      case 'int':
        out.print("int");
        emit_expr(out, args[0].arg);
        break;      
      case 'typeof':
        out.print("wxx_typeof");
        emit_expr(out, args[0].arg);
        break;
      case 'getstdin':
      case 'getstdout':
      case 'getstderr':
        out.print("wxx_" + name + "()");
        break;
      case 'print':
      case 'say':
        for (i = 0;  i < nargs; ++i) {
            var arg = args[i];
            var argexp = arg.arg;
            out.print('wxx_print');
            emit_expr(out, argexp);
            out.print(',');
        }
        if (predef.name == 'say')
            out.print('wxx_print("\n"),');
        out.print('0');
        break;
      case 'cry':
        for (i = 0;  i < nargs; ++i) {
            var arg = args[i];
            var argexp = arg.arg;
            out.print('wxx_eprint');
            emit_expr(out, argexp);
            out.print(',');
        }
        out.print('wxx_eprint("\n"),');
        out.print('0');
        break;
      case 'elements':
        emit_expr(out, args[0].arg);
        out.print(".elements()");
        break;
      case 'length':
      case 'bytelength':
        emit_expr(out, args[0].arg);
        out.print(".length()");
        break;
      case 'ord':
        out.print("(unsigned char)(");
        emit_expr(out, args[0].arg);
        out.print(".c_str()[0])");
        break;
      case 'chr':
        out.print("WxxObjectPtr(std::string(1, int(");
        emit_expr(out, args[0].arg);
        out.print(")))");
        break;
      case 'indexof':
        out.print("int((");
        emit_expr(out, args[0].arg);
        out.print(").find(");
        emit_expr(out, args[1].arg);
        out.print("))");
        break;
      case 'substr':
        emit_expr(out, args[0].arg);
        out.print(".substr(");
        emit_expr(out, args[1].arg);
        if (nargs > 2) {
            out.print(", ");
            emit_expr(out, args[2].arg);
        }
        out.print(")");
        break;
      case 'join':
        out.print("wxx_join(");
        emit_expr(out, args[0].arg);
        out.print(", ");
        emit_expr(out, args[1].arg);
        out.print(")");
        break;
      case 'Error':
        out.print("wxx_error(");
        emit_expr(out, args[0].arg);
        if (nargs > 1) {
            out.print(", ");
            emit_expr(out, args[1].arg);
        }
        if (nargs > 2) {
            out.print(", ");
            emit_expr(out, args[2].arg);
        }
        out.print(")");
        break;
      case 'open':
        out.print("WxxObjectPtr((new WxxFileHandle())->open(");
        emit_expr(out, args[0].arg);
        if (nargs > 1) {
            out.print(", ");
            emit_expr(out, args[1].arg);
        }
        out.print("))");
        break;
      case 'load_language':
        // Cannot do it, always return null
        out.print("winxedxxnull");
        break;
      case 'compreg':
        // Cannot do it, always return null
        out.print("winxedxxnull");
        break;
      case 'loadlib':
        out.print("wxx_loadlib");
        emit_expr(out, args[0].arg);
        break;
      case 'dlfunc':
        var sig = args[2].arg;
        if (! sig.isstringliteral())
            throw Error("dlfunc siganture must be compile time constant");
        int nsigargs = length(sig.strval.rawstring()) - 1;
        string csig = ncisigtoc(sig.strval.rawstring());

        out.print("wxx_dlfunc<" + csig + ", " + string(nsigargs) + ">(");
        emit_expr(out, args[0].arg);
        out.print(", ");
        emit_expr(out, args[1].arg);
        out.print(")");
        break;
      default:
        WxxUnsupported(expr, "predef " + name);
    }
}

function emit_callexpr(out, callexpr)
{
    var funref = callexpr.funref;
    var args = callexpr.args;
    int nargs = 0;
    if (args != null)
        nargs = args.numargs();
    if (funref.isidentifier()) {
        string callname = funref.getName();
        out.print(callname);
        out.print("(WinxedXX::WxxObjectArray()");
        if (nargs > 0) {
            for (int i = 0; i < nargs; ++i) {
                out.print(".push(");
                var arg = args.getfreearg(i);
                emit_expr(out, arg);
                out.print(")");
            }
        }
        out.print(")");
    }
    else if (funref instanceof MemberExpr) {
        emit_expr(out, funref.left);
        out.print(".call_method(\"");
        out.print(funref.right.getidentifier());
        out.print("\"");
        if (nargs > 0) {
            out.print(", WinxedXX::WxxObjectArray()");
            for (int i = 0; i < nargs; ++i) {
                out.print(".push(");
                var arg = args.getfreearg(i);
                emit_expr(out, arg);
                out.print(")");
            }
        }
        out.print(")");
    }
    else
        WxxUnsupported(funref);
}

function emit_arrayexpr(out, expr)
{
    var values = expr.values;
    int nvalues = values == null ? 0 : elements(values);
    out.print("WxxObjectPtr(&((* new WxxObjectArray())");
    int i;
    for (i = 0; i < nvalues; ++i) {
        out.print(".push");
        emit_expr(out, values[i]);
    }
    out.print("))");
}

function emit_hashexpr(out, expr)
{
    var keys = expr.keys;
    var values = expr.values;
    int n = elements(keys);
    out.print("WxxObjectPtr(&((* new WxxHash())");
    int i;
    for (i = 0; i < n; ++i) {
        out.print(".set(");
        emit_expr(out, keys[i]);
        out.print(", ");
        emit_expr(out, values[i]);
        out.print(")");
    }
    out.print("))");
}

function emit_newexpr(out, expr)
{
    var value = expr.value;
    if (! value.isidentifier())
        WxxUnsupported(expr);
    out.print("WxxObjectPtr(new WxxInstance(\"" + string(value) + "\"))");
}

function emit_assignexpr(out, assignexpr)
{
    var lexpr = assignexpr.lexpr;
    var rexpr = assignexpr.rexpr;
    if (lexpr instanceof IdentifierExpr) {
        out.print(lexpr.name);
        out.print(" = ");
        // Coerce result type to avoid ambiguities
        switch (lexpr.checkresult()) {
          case 'S':
            out.print("std::string"); break;
          case 'I':
            out.print("int"); break;
          case 'F':
            out.print("float"); break;
        }
        emit_expr(out, rexpr);
    }
    else if (lexpr instanceof MemberExpr) {
        emit_expr(out, lexpr.left);
        string ident = lexpr.right.getidentifier();
        out.print(".set_attr_str(\"" + ident + "\",");
        emit_expr(out, rexpr);
        out.print(")");
    }
    else if (lexpr instanceof IndexExpr) {
        var left = lexpr.left;
        emit_expr(out, left);
        var arg = lexpr.getarg(0);
        out.print(".set_pmc_keyed(");
        emit_expr(out, arg);
        out.print(", ");
        emit_expr(out, rexpr);
        out.print(")");
    }
    else
        WxxUnsupported(lexpr);
}

function emit_assigntoexpr(out, expr)
{
    var lexpr = expr.lexpr;
    var rexpr = expr.rexpr;
    if (lexpr instanceof IdentifierExpr) {
        out.print(lexpr.name);
        out.print(".set");
        emit_expr(out, rexpr);
    }
    else if (lexpr instanceof MemberExpr) {
        emit_expr(out, lexpr.left);
        string ident = lexpr.right.getidentifier();
        out.print(".get_attr_str(\"" + ident + "\").set");
        emit_expr(out, rexpr);
    }
    else
        WxxUnsupported(lexpr);
}

function emit_instanceofexpr(out, instanceofexpr)
{
    var lexpr = instanceofexpr.lexpr;
    var checked = instanceofexpr.checked;
    out.print("wxx_instanceof(");
    emit_expr(out, lexpr);
    out.print(", ");
    if (checked.isidentifier())
        out.print('"' + string(checked.getidentifier()) + '"');
    else
        out.print('"' + string(tokstringtoxx(checked)) + '"');
    out.print(")");
}

function emit_addtoexpr(out, assignexpr)
{
    var lexpr = assignexpr.lexpr;
    if (lexpr instanceof IdentifierExpr) {
        out.print(lexpr.name);
        out.print(" += ");
        emit_expr(out, assignexpr.rexpr);
    }
    else
        WxxUnsupported(lexpr);
}

function emit_addexpr(out, expr)
{
    var lexpr = expr.lexpr;
    var rexpr = expr.rexpr;
    emit_expr(out, lexpr);
    out.print(" + ");
    emit_expr(out, rexpr);
}

function emit_subexpr(out, expr)
{
    var lexpr = expr.lexpr;
    var rexpr = expr.rexpr;
    emit_expr(out, lexpr);
    out.print(" - ");
    emit_expr(out, rexpr);
}

function emit_mulexpr(out, expr)
{
    var lexpr = expr.lexpr;
    var rexpr = expr.rexpr;
    emit_expr(out, lexpr);
    out.print(" * ");
    emit_expr(out, rexpr);
}

function emit_divexpr(out, expr)
{
    var lexpr = expr.lexpr;
    var rexpr = expr.rexpr;
    emit_expr(out, lexpr);
    out.print(" / ");
    emit_expr(out, rexpr);
}

function emit_concatstring(out, concatstr)
{
    var values = concatstr.values;
    emit_expr(out, values[0]);
    int n = elements(values);
    for (int i = 1; i < n; ++i) {
        out.print(" + ");
        emit_expr(out, values[i]);
    }
}

function emit_nullchecker(out, expr)
{
    if (! expr.checknull)
        out.print("!");
    out.print("(");
    out.print("wxx_isnull");
    emit_expr(out, expr.expr);
    out.print(")");
}

function emit_opnot(out, expr)
{
    out.print("!");
    emit_expr(out, expr.subexpr);
}

function emit_commonop(out, expr, string opstr)
{
    emit_expr(out, expr.lexpr);
    out.print(" ");
    out.print(opstr);
    out.print(" ");
    emit_expr(out, expr.rexpr);
}

function emit_boolorexpr(out, lessexpr)
{
    out.print("wxx_boolor(");
    emit_expr(out, lessexpr.lexpr);
    out.print(", ");
    emit_expr(out, lessexpr.rexpr);
    out.print(")");
}

function emit_boolandexpr(out, lessexpr)
{
    out.print("wxx_booland(");
    emit_expr(out, lessexpr.lexpr);
    out.print(", ");
    emit_expr(out, lessexpr.rexpr);
    out.print(")");
}

function emit_conditionalexpr(out, expr)
{
    emit_expr(out, expr.condition.condexpr);
    out.print(" ? ");
    emit_expr(out, expr.etrue);
    out.print(" : ");
    emit_expr(out, expr.efalse);
}

function emit_identifierexpr(out, expr)
{
    string name = expr.name;
    if (name == "null")
        out.print("winxednull");
    else
        out.print(name);
}

function emit_indexexpr(out, expr)
{
    var left = expr.left;
    emit_expr(out, left);
    var arg = expr.getarg(0);
    out.print(".get_pmc_keyed");
    emit_expr(out, arg);
}

function emit_memberexpr(out, expr)
{
    emit_expr(out, expr.left);
    out.print(".get_attr_str(\"");
    out.print(expr.right.getidentifier());
    out.print("\")");
}

function emit_expr(out, expr)
{
    out.print("(");

    if (expr instanceof CallPredefExpr)
        emit_callpredefexpr(out, expr);
    else if (expr instanceof CallExpr)
        emit_callexpr(out, expr);
    else if (expr instanceof OpAssignExpr)
        emit_assignexpr(out, expr);
    else if (expr instanceof OpAssignToExpr)
        emit_assigntoexpr(out, expr);
    else if (expr instanceof OpAddToExpr)
        emit_addtoexpr(out, expr);
    else if (expr instanceof IdentifierExpr)
        emit_identifierexpr(out, expr);
    else if (expr instanceof IntegerLiteral)
        out.print(expr.getIntegerValue());
    else if (expr instanceof FloatLiteral)
        out.print(expr.numval);
    else if (expr instanceof StringLiteral) {
        out.print('std::string("');
        out.print(stringtoxx(expr));
        out.print('")');
    }
    else if (expr instanceof NewExpr)
        emit_newexpr(out, expr);
    else if (expr instanceof ArrayExpr)
        emit_arrayexpr(out, expr);
    else if (expr instanceof HashExpr)
        emit_hashexpr(out, expr);
    else if (expr instanceof OpNotExpr)
        emit_opnot(out, expr);
    else if (expr instanceof NullCheckerExpr)
        emit_nullchecker(out, expr);
    else if (expr instanceof OpInstanceOfExpr)
        emit_instanceofexpr(out, expr);
    else if (expr instanceof OpPreIncExpr) {
        out.print('++');
        emit_expr(out, expr.subexpr);
    }
    else if (expr instanceof OpPreDecExpr) {
        out.print('--');
        emit_expr(out, expr.subexpr);
    }
    else if (expr instanceof OpPostIncExpr) {
        emit_expr(out, expr.subexpr);
        out.print('++');
    }
    else if (expr instanceof OpPostDecExpr) {
        emit_expr(out, expr.subexpr);
        out.print('--');
    }
    else if (expr instanceof OpAddExpr)
        emit_addexpr(out, expr);
    else if (expr instanceof OpSubExpr)
        emit_subexpr(out, expr);
    else if (expr instanceof OpMulExpr)
        emit_mulexpr(out, expr);
    else if (expr instanceof OpDivExpr)
        emit_divexpr(out, expr);
    else if (expr instanceof ConcatString)
        emit_concatstring(out, expr);
    else if (expr instanceof OpEqualExpr)
        emit_commonop(out, expr, "==");
    else if (expr instanceof OpNotEqualExpr)
        emit_commonop(out, expr, "!=");
    else if (expr instanceof OpLessEqualExpr)
        emit_commonop(out, expr, "<=");
    else if (expr instanceof OpLessExpr)
        emit_commonop(out, expr, "<");
    else if (expr instanceof OpGreaterExpr)
        emit_commonop(out, expr, ">");
    else if (expr instanceof OpGreaterEqualExpr)
        emit_commonop(out, expr, ">=");
    else if (expr instanceof OpBoolOrExpr)
        emit_boolorexpr(out, expr);
    else if (expr instanceof OpBoolAndExpr)
        emit_boolandexpr(out, expr);
    else if (expr instanceof OpModExpr)
        emit_commonop(out, expr, "%");
    else if (expr instanceof OpCModExpr)
        emit_commonop(out, expr, "%");
    else if (expr instanceof OpConditionalExpr)
        emit_conditionalexpr(out, expr);
    else if (expr instanceof MemberExpr)
        emit_memberexpr(out, expr);
    else if (expr instanceof IndexExpr)
        emit_indexexpr(out, expr);
    else
        WxxUnsupported(expr);
    out.print(")");
}

function emit_exprst(out, exprst)
{
    var expr = exprst.expr;
    emit_expr(out, expr);
}

function emit_conststatement(out, st)
{
}

function emit_varstatement(out, st)
{
    out.print("WxxObjectPtr ");
    out.print(st.name);
    var init = st.init;
    if (init != null) {
        out.print(" = ");
        emit_expr(out, init);
    }
}

function emit_nativetypestatement(out, st,
        string simpletype, string arraytype, string nullinit)
{
    string name = st.name;
    int typearray = st.typearray;
    var init = st.init;
    if (typearray == 0) {
        out.print(simpletype);
        out.print(" ");
        out.print(name);
        if (init == null) {
            out.print(" = ");
            out.print(nullinit);
        }
        else {
            out.print(" = ");
            emit_expr(out, init);
        }
    }
    else {
        out.print("WxxObjectPtr ");
        out.print(name);
        out.print("(&((*new Wxx");
        out.print(arraytype);
        out.print("Array())");
        if (init != null) {
            for (var item in init) {
                out.print(".push(");
                emit_expr(out, item);
                out.print(")");
            }
        }
        out.print("))");
    }
}

function emit_labelstatement(out, labelst)
{
    out.print(labelst.name);
    out.print(":\n");
}

function emit_breakstatement(out, gotost)
{
    out.print("break");
}

function emit_gotostatement(out, gotost)
{
    out.print("goto ");
    out.print(gotost.label);
}

function emit_ifstatement(out, ifst)
{
    var truebranch = ifst.truebranch;
    var falsebranch = ifst.falsebranch;
    out.print('if ');
    emit_expr(out, ifst.condexpr);
    out.print("\n{\n");
    if (! truebranch.isempty())
        emit_statement(out, truebranch);
    out.print("} else {\n");
    if (! falsebranch.isempty())
        emit_statement(out, falsebranch);
    out.print("}\n");
}

function emit_switchstatement(out, switchst)
{
    var case_value = switchst.case_value;
    var case_st = switchst.case_st;
    out.print("do {\nWxxObjectPtr wxxswvar = ");
    emit_expr(out, switchst.condition);
    out.print(";\n");

    int n = elements(case_st);
    for (int i = 0; i < n; ++i) {
        var caseval = case_value[i];
        out.print ("if (wxxswvar == ");
        emit_expr(out, caseval);
        out.print(") {\n");
        int nst = elements(case_st[i]);
        int j;
        for (j = 0; j < nst; ++j)
            emit_statement(out, case_st[i][j]);
        out.print("}\n");
    }

    out.print("} while (false)\n");
}

function emit_whilestatement(out, whilest)
{
    out.print('while ');
    emit_expr(out, whilest.condexpr);
    out.print("\n{\n");
    emit_statement(out, whilest.body);
    out.print("}\n");
}

function emit_dostatement(out, dost)
{
    out.print("do {\n");
    emit_statement(out, dost.body);
    out.print("} while ");
    emit_expr(out, dost.condexpr);
}

function emit_trystatement(out, tryst)
{
    out.print("try\n{\n");
    emit_statement(out, tryst.stry);
    out.print("}\ncatch (");
    if (tryst.exname == null)
        out.print("...");
    else {
        out.print("WxxObjectPtr &");
        out.print(string(tryst.exname));
    }
    out.print(")\n{\n");
    emit_statement(out, tryst.scatch);
    out.print("}\n");
}

function emit_throwstatement(out, throwst)
{
    out.print("throw ");
    emit_expr(out, throwst.excep);
}

function emit_forstatement(out, forst)
{
    var initializer = forst.initializer;
    var condexpr = forst.condexpr;
    var iteration = forst.iteration;
    out.print("for (");
    if (initializer != null)
        emit_statement(out, initializer);
    else
        out.print(";");
    if (condexpr != null)
        emit_expr(out, forst.condexpr);
    out.print(";");
    if (iteration != null)
        emit_expr(out, forst.iteration);
    out.print(") {\n");
    emit_statement(out, forst.body);
    out.print("}\n");
}

function emit_foreachstatement(out, forst)
{
    var varname = forst.varname;
    var container = forst.container;
    out.print("{\nWxxObjectPtr wxx_it = ");
    emit_expr(out, container);
    out.print(".get_iter();\nwhile (bool(wxx_it)) {\n");
    string type = forst.deftype == null ? '' : string(forst.deftype);
    switch (type) {
      case 'I':
        out.print("int "); break;
      case 'N':
        out.print("double "); break;
      case 'S':
        out.print("std::string "); break;
      case 'P':
        out.print("WxxObjectPtr "); break;
      default:
        /* nothing */;
    }
    out.print(varname);
    out.print(" = wxx_it.shift_pmc();\n");
    emit_statement(out, forst.body);
    out.print("}\n}\n");
}

function emit_returnstatement(out, returnst)
{
    var values = returnst.values;
    int nargs = values == null ? 0 : int(values.numargs());
    switch (nargs) {
      case 0:
        out.print("return WxxObjectPtr()");
        break;
      case 1:
        var expr = values.getfreearg(0);
        out.print("return ");
        emit_expr(out, expr);
        break;
      default:
        WxxUnsupported(returnst);
    }
}

function emit_compoundstatement(out, compound)
{
    var stlist = compound.statements;
    int nst = elements(stlist);
    int i;
    out.print("{\n");
    for (i = 0; i < nst; ++i) {
        var st = stlist[i];
        emit_statement(out, st);
    }
    out.print("}\n");
}

function emit_multistatement(out, mst)
{
    var stlist = mst.statements;
    int nst = elements(stlist);
    int i;
    for (i = 0; i < nst; ++i) {
        var st = stlist[i];
        emit_statement(out, st);
    }
}

function emit_statement(out, st)
{
    if (st instanceof MultiStatement)
        emit_multistatement(out, st);
    else if (st instanceof CompoundStatement)
        emit_compoundstatement(out, st);
    else if (st instanceof ConstStatement)
        emit_conststatement(out, st);
    else if (st instanceof IntStatement)
        emit_nativetypestatement(out, st, "int", "Integer", "0");
    else if (st instanceof FloatStatement)
        emit_nativetypestatement(out, st, "double", "Float", "0.0");
    else if (st instanceof StringStatement)
        emit_nativetypestatement(out, st, "std::string", "String", '""');
    else if (st instanceof VarStatement)
        emit_varstatement(out, st);
    else if (st instanceof LabelStatement)
        emit_labelstatement(out, st);
    else if (st instanceof BreakStatement)
        emit_breakstatement(out, st);
    else if (st instanceof GotoStatement)
        emit_gotostatement(out, st);
    else if (st instanceof IfStatement)
        emit_ifstatement(out, st);
    else if (st instanceof SwitchStatement)
        emit_switchstatement(out, st);
    else if (st instanceof WhileStatement)
        emit_whilestatement(out, st);
    else if (st instanceof DoStatement)
        emit_dostatement(out, st);
    else if (st instanceof TryStatement)
        emit_trystatement(out, st);
    else if (st instanceof ThrowStatement)
        emit_throwstatement(out, st);
    else if (st instanceof ForStatement)
        emit_forstatement(out, st);
    else if (st instanceof ForeachStatement)
        emit_foreachstatement(out, st);
    else if (st instanceof ReturnStatement)
        emit_returnstatement(out, st);
    else if (st instanceof ExprStatement)
        emit_exprst(out, st);
    else if (st instanceof EmptyStatement)
        /* Do nothing */ ;
    else if (st instanceof ExternStatement)
        /* Do nothing */ ;
    else if (st instanceof StaticStatement)
        /* Do nothing */ ;
    else if (st instanceof UsingStatement)
        /* Do nothing */ ;
    else
        WxxUnsupported(st);
    out.print(";\n");
}

function emit_declare_function(out, funst)
{
    string name = funst.name;
    out.print('WxxObjectPtr ');
    out.print(name);
    out.print("(const WxxObjectArray &wxx_fun_args);\n");
}

function emit_function(out, funst)
{
    string name = funst.name;
    int ismethod = funst.ismethod();

    if (ismethod)
        out.print("static ");
    out.print('WxxObjectPtr ');
    out.print(name);
    out.print("(");

    if (ismethod)
        out.print("WxxObjectPtr &self, ");
    out.print("const WxxObjectArray &wxx_fun_args");
    out.print(")\n{\n");
    var params = funst.params;
    int nparams = params == null ? 0 : elements(params);
    int i;
    for (i = 0; i < nparams; ++i) {
        var param = params[i];
        string name = param['name'];
        var a = funst.getvar(name);
        string type = a.gettype();
        switch (type) {
          case 'I':
            out.print("int"); break;
          case 'N':
            out.print("double"); break;
          case 'S':
            out.print("std::string"); break;
          default:
            out.print("WxxObjectPtr"); break;
        }
        out.print(" ");
        out.print(name);
        out.print(" = (wxx_fun_args[");
        out.print(i);
        out.print("]);\n");
    }

    // Get body. Should be a CompundStatement
    var body = funst.body;
    emit_statement(out, body);
    out.print("\nreturn winxedxxnull;\n}\n");
}

//**************************************************************

function get_winxed_compiler()
{
    // Load language module. If that fails, load the stage 2 bytecode.
    var winxed;
    try {
        winxed = load_language('winxed');
    } catch () { }
    if (winxed == null) {
        using extern winxedst2; // Must be installed, or use -L
        winxed = compreg('winxed');
    }
    return winxed;
}

function emit_classst(out, clst)
{
    string name = clst.name;
    var members = clst.members;
    var functions = clst.functions;

    out.print("class ");
    out.print(name);
    out.print("\n{\n");

    int nfunctions = elements(functions);
    int i;
    for (i = 0; i < nfunctions; ++i)
        emit_function(out, functions[i]);

    out.print(<<:CLINIT
static WxxClass * init_class()
{
    WxxClass *cl = new WxxClass(
CLINIT:>>
    );
    out.print('"' + name + '"');
    out.print(<<:CLINIT
        );
CLINIT:>>
    );
    for (i = 0; i < elements(members); ++i) {
        var member = members[i];
        out.print("cl->addattribute(\"" + string(member) + "\");\n");
    }
    for (i = 0; i < nfunctions; ++i) {
        var fun = functions[i];
        string fname = fun.name;
        out.print("cl->addfunction(\"" + fname +
                "\", &" + name + "::" + fname + ");\n");
    }

    out.print("return cl;\n}\n");

    out.print("static WxxClass *clreg;\n};\n");

    out.print("WxxClass * " + name + "::clreg = " + name + "::init_class();");
    //WxxUnsupported(clst, "class is still");
}

function emit_namespacest(out, ns)
{
    if (! (ns instanceof RootNamespace)) {
        out.print("namespace ");
        out.print(ns.name);
        out.print("\n{\n");
    }

    for (var item in ns.items) {
        if (item instanceof FunctionStatement)
            emit_function(out, item);
        else if (item instanceof NamespaceStatement)
            emit_namespacest(out, item);
        else if (item instanceof ClassStatement)
            emit_classst(out, item);
        else if (item instanceof MultiStatement)
            emit_statement(out, item);
        else if (item instanceof ConstStatement)
            /* ignored */;
        else
            WxxUnsupported(item);
    }
    if (! (ns instanceof RootNamespace))
        out.print("\n}\n");
}

function emit_declare_namespacest(out, ns)
{
    if (! (ns instanceof RootNamespace)) {
        out.print("namespace ");
        out.print(ns.name);
        out.print("\n{\n");
    }

    // Declare functions
    for (var fun in ns.functions)
        emit_declare_function(out, fun);

    // Declare child namespaces
    for (var childns in ns.namespaces)
        emit_declare_namespacest(out, childns);

    if (! (ns instanceof RootNamespace))
        out.print("\n}\n");
}

function get_main(ns)
{
    int i;
    var functions = ns.functions;
    int nfunctions = elements(functions);
    for (i = 0; i < nfunctions; ++i) {
        var fun = functions[i];
        var modifiers = fun.modifiers;
        if (modifiers != null && modifiers.pick('main') != null)
            return fun.name;
        if (fun.name == 'main')
            return 'main';
    }
    return '';
}

function emit(out, parsed)
{
    var ns = parsed.rootns;
    string mainfunc = get_main(ns);

    out.print(<<:HEADER
// Generated by winxedxx

#include "winxedxx.h"

namespace WinxedXX
{

HEADER:>>
    );

    emit_declare_namespacest(out, ns);

    emit_namespacest(out, ns);

    out.print(<<:FOOTER1
} // namespace WinxedXX

FOOTER1:>>
    );

    if (mainfunc != '') {
        out.print(<<:FOOTER2
int main(int argc, char **argv)
{
    try {
        WinxedXX::WxxObjectArray *args = new WinxedXX::WxxObjectArray();
        for (int i = 0; i < argc; ++i)
            args->push(argv[i]);
        WinxedXX::WxxObjectPtr mainarg(args);
        WinxedXX::WxxObjectPtr objresult =
                WinxedXX::
FOOTER2:>>
        );

        out.print(mainfunc);

        out.print(<<:FOOTER3
                (WinxedXX::WxxObjectArray().push(mainarg));
        int result = objresult.is_null() ? 0 : int(objresult);
        return result;
    }
    catch (WinxedXX::WxxObjectPtr &e) {
        std::cerr << "Exception caught:\n\t";
        std::cerr.flush();
        std::cerr << e.get_string() << '\n';
        return 1;
    }
    catch (const std::exception &e) {
        std::cerr << "Error: " << e.what() << '\n';
        return 1;
    }
}
FOOTER3:>>

        );
    }
    out.print("// End\n");
}

function winxedxx_get_options(argv)
{
    int argc = elements(argv);
    int i;
    var options = {};
    int nomore = false;
    for (i = 1; i < argc; ++i) {
        switch (argv[i]) {
          case '-o':
            options['outfile'] = argv[++i];
            break;
          case '--target':
            options['target'] = argv[++i];
            break;
          default:
            nomore = true;
        }
        if (nomore)
            break;
    }
    if (i >= argc)
        throw Error("No source file");
    options['sourcefile'] = argv[i];
    return options;
}

function winxedxx_compile(options)
{
    var winxed = get_winxed_compiler();
    string sourcefile = options['sourcefile'];
    var parsed = winxed.compile_from_file(sourcefile,
        'parse':[named('target')]
    );

    string outfile = options['outfile'];
    if (outfile == null)
        outfile = '';
    string cxxfile = outfile;
    var target = options["target"];
    if (target == null)
        target = 'cxx';
    switch (target) {
      case 'exe':
      case 'run':
        if (outfile == '') {
            outfile = sourcefile + '.exe';
            cxxfile = sourcefile + '.cxx';
        }
        else
            cxxfile = outfile + '.cxx';
        break;
      case 'cxx':
        /* Nothing in particular */
        break;
      default:
        throw Error("Invalid target type: " + string(target));
    }
    var out = cxxfile != '' ?
        open(cxxfile, "w") :
        getstdout();
    emit(out, parsed);
    if (cxxfile != '')
        out.close();
    int r = 0;
    switch (target) {
      case 'exe':
        r = spawnw(["g++", "-Wall", "-O2", "-ldl", "-o", outfile, cxxfile]);
        r = (r >> 8) & 0xFF;
        break;
      case 'run':
        r = spawnw(["g++", "-Wall", "-O2", "-ldl", "-o", outfile, cxxfile]);
        r = (r >> 8) & 0xFF;
        if (r != 0)
            break;
        r = spawnw(["./" + outfile]);
        r = (r >> 8) & 0xFF;
        break;
    }
    return r;
}

function main(argv)
{
    try {
        var options = winxedxx_get_options(argv);
        int r = winxedxx_compile(options);
        return r;
    }
    catch (e) {
        cry(e.message);
        return 1;
    }
}

// End
