#! winxed

// winxedxx.winxed
// C++ backend for winxed
// (C) 2011 Juli√°n Albo "NotFound"

// This code uses and abuses winxed compiler internals.
// Not a good example on how to write winxed compiler extensions winxed,
// but there is no better way right now.

function WxxUnsupported(thing)
{
    string stname;
    if (thing instanceof 'String')
        stname = thing;
    else
        stname = typeof(thing);
    string filename = '';
    int line = 0;
    string desc;
    try {
        var start = thing.start;
        filename = start.file;
        line = start.line;
        desc = start.viewable();
    }
    catch () { }
    throw Error(filename + ":" + string(line) + ": " +
            stname + " unsupported near " + desc);
}

function tokstringtoxx(strval)
{
    string str = strval.str;
    if (strval instanceof TokenQuoted)
        return str;
    if (strval instanceof TokenSingleQuoted)
    {
        string result = '';
        for (string c in str) {
            switch (c) {
              case '"':
              case '\':
                result += '\' + c;
                break;
              default:
                result += c;
            }
        }
        return result;
    }
    die('Unexpected literal string type');
}

function stringtoxx(literal)
{
    var strval = literal.strval;
    string str = strval.str;
    if (strval instanceof TokenQuoted)
        return str;
    if (strval instanceof TokenSingleQuoted)
    {
        string result = '';
        for (string c in str) {
            switch (c) {
              case '"':
              case '\':
                result += '\' + c;
                break;
              default:
                result += c;
            }
        }
        return result;
    }
    die('Unexpected literal string type');
}

function emit_callpredefexpr(out, expr)
{
    var predef = expr.predef;
    string name = predef.name;
    var args = expr.args;
    switch (name) {
      case 'print':
      case 'say':
        out.print('(');
        for (var arg in args) {
            var argexp = arg.arg;
            out.print('wxx_print(');
            emit_expr(out, argexp);
            out.print('),');
        }
        if (predef.name == 'say')
            out.print('wxx_print("\n"),');
        out.print('0)');
        break;
      default:
        WxxUnsupported(name);
    }
}

function emit_callexpr(out, callexpr)
{
    var funref = callexpr.funref;
    if (funref.isidentifier()) {
        string callname = funref.getName();
        out.print(callname);
        out.print("()");
    }
}

function emit_assignexpr(out, assignexpr)
{
    var lexpr = assignexpr.lexpr;
    if (lexpr instanceof IdentifierExpr) {
        out.print(lexpr.name);
        out.print(" = ");
        emit_expr(out, assignexpr.rexpr);
    }
    else
        WxxUnsupported(lexpr);
}

function emit_instanceofexpr(out, instanceofexpr)
{
    var lexpr = instanceofexpr.lexpr;
    var checked = instanceofexpr.checked;
    out.print("wxx_instanceof(");
    emit_expr(out, lexpr);
    out.print(", ");
    if (checked.isidentifier())
        out.print('"' + string(checked.getidentifier()) + '"');
    else
        out.print('"' + string(tokstringtoxx(checked)) + '"');
    out.print(")");
}

function emit_lessexpr(out, lessexpr)
{
    out.print("((");
    emit_expr(out, lessexpr.lexpr);
    out.print(") < (");
    emit_expr(out, lessexpr.rexpr);
    out.print("))");
}

function emit_greaterexpr(out, lessexpr)
{
    out.print("((");
    emit_expr(out, lessexpr.lexpr);
    out.print(") > (");
    emit_expr(out, lessexpr.rexpr);
    out.print("))");
}

function emit_expr(out, expr)
{
    if (expr instanceof CallPredefExpr)
        emit_callpredefexpr(out, expr);
    else if (expr instanceof CallExpr)
        emit_callexpr(out, expr);
    else if (expr instanceof OpAssignExpr)
        emit_assignexpr(out, expr);
    else if (expr instanceof IdentifierExpr)
        out.print(expr.name);
    else if (expr instanceof IntegerLiteral)
        out.print(expr.getIntegerValue());
    else if (expr instanceof FloatLiteral)
        out.print(expr.numval);
    else if (expr instanceof StringLiteral) {
        out.print('"');
        out.print(stringtoxx(expr));
        out.print('"');
    }
    else if (expr instanceof OpInstanceOfExpr)
        emit_instanceofexpr(out, expr);
    else if (expr instanceof OpPreIncExpr) {
        out.print('++(');
        emit_expr(out, expr.subexpr);
        out.print(')');
    }
    else if (expr instanceof OpLessExpr)
        emit_lessexpr(out, expr);
    else if (expr instanceof OpGreaterExpr)
        emit_greaterexpr(out, expr);
    else if (expr instanceof OpPreDecExpr) {
        out.print('--(');
        emit_expr(out, expr.subexpr);
        out.print(')');
    }
    else
        WxxUnsupported(expr);
}

function emit_exprst(out, exprst)
{
    var expr = exprst.expr;
    emit_expr(out, expr);
}

function emit_varstatement(out, st)
{
    out.print("WxxObjectPtr ");
    out.print(st.name);
}

function emit_intstatement(out, st)
{
    out.print("int ");
    out.print(st.name);
    if (st.init == null)
        out.print(" = 0");
    else {
        out.print(" = ");
        emit_expr(out, st.init);
    }
}

function emit_floatstatement(out, st)
{
    out.print("double ");
    out.print(st.name);
    if (st.init == null)
        out.print(" = 0.0");
    else {
        out.print(" = ");
        emit_expr(out, st.init);
    }
}

function emit_stringstatement(out, st)
{
    out.print("std::string ");
    out.print(st.name);
    if (st.init == null)
        out.print(' = ""');
    else {
        out.print(" = ");
        emit_expr(out, st.init);
    }
}

function emit_labelstatement(out, labelst)
{
    out.print(labelst.name);
    out.print(":\n");
}

function emit_gotostatement(out, gotost)
{
    out.print("goto ");
    out.print(gotost.label);
}

function emit_ifstatement(out, ifst)
{
    out.print('if (');
    emit_expr(out, ifst.condexpr);
    out.print(")\n");
    emit_statement(out, ifst.truebranch);
}

function emit_forstatement(out, forst)
{
    emit_statement(out, forst.initializer);

    out.print("for (");
    emit_statement(out, forst.initializer);
    emit_expr(out, forst.condexpr);
    out.print(";");
    emit_expr(out, forst.iteration);
    out.print(") {\n");
    emit_statement(out, forst.body);
    out.print("}\n");
}

function emit_compoundstatement(out, compound)
{
    var stlist = compound.statements;
    int nst = elements(stlist);
    for (var st in stlist)
        emit_statement(out, st);
}

function emit_statement(out, st)
{
    if (st instanceof CompoundStatement)
        emit_compoundstatement(out, st);
    else if (st instanceof IntStatement)
        emit_intstatement(out, st);
    else if (st instanceof FloatStatement)
        emit_floatstatement(out, st);
    else if (st instanceof StringStatement)
        emit_stringstatement(out, st);
    else if (st instanceof VarStatement)
        emit_varstatement(out, st);
    else if (st instanceof LabelStatement)
        emit_labelstatement(out, st);
    else if (st instanceof GotoStatement)
        emit_gotostatement(out, st);
    else if (st instanceof IfStatement)
        emit_ifstatement(out, st);
    else if (st instanceof ForStatement)
        emit_forstatement(out, st);
    else if (st instanceof ExprStatement)
        emit_exprst(out, st);
    else
        WxxUnsupported(st);
    out.print(";\n");
}

function emit_function(out, funst)
{
    string name = funst.name;

    /*if (name == 'main')
        out.print('int main');
    else */{
        out.print('WxxObjectPtr ');
        out.print(name);
    }
    out.print("()\n{\n");

    // Get body. Should be a CompundStatement
    var body = funst.body;
    emit_statement(out, body);
    out.print("\nreturn winxedxxnull;\n}\n");
}

//**************************************************************

function get_winxed_compiler()
{
    // Load language module. If that fails, load the stage 2 bytecode.
    var winxed;
    try {
        winxed = load_language('winxed');
    } catch () { }
    if (winxed == null) {
        using extern winxedst2; // Must be installed, or use -L
        winxed = compreg('winxed');
    }
    return winxed;
}

function emit(out, parsed)
{
    out.print(<<:HEADER
// Generated by winxedxx

#include "winxedxx.h"

namespace WinxedXX
{

HEADER:>>
    );

    var ns = parsed.rootns;
    var functions = ns.functions;
    for (var funst in functions)
        emit_function(out, funst);

    out.print(<<:FOOTER
} // namespace WinxedXX

int main(int argc, char **argv)
{
    try {
        WinxedXX::WxxObjectPtr result = WinxedXX::main();
        return int(result);
    }
    catch (WinxedXX::WxxObjectPtr &e) {
        std::cerr << "Exception caught:\n\t";
        std::cerr.flush();
        std::cerr << e.get_string() << '\n';
        return 1;
    }
    catch (const std::exception &e) {
        std::cerr << "Error: " << e.what() << '\n';
        return 1;
    }
}

// End
FOOTER:>>
    );
}

function main(argv)
{
    try {
        var winxed = get_winxed_compiler();
        var parsed = winxed.compile_from_file(argv[1], 'parse':[named('target')]);

        var out;
        ${ getstdout out };
        emit(out, parsed);
        return 0;
    }
    catch (e) {
        cry(e.message);
        return 1;
    }
}

// End
